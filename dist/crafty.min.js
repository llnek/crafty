!function(t,e){"use strict";function s(s){s||(s=t["io/czlab/mcfud/core"]());const i=(t,e)=>t<e?-1:t>e?1:0,r=Math.floor,{is:n,u:o}=s,h=t=>o.assert(n.num(t)||n.str(t),"expected number or string");function l(t,e=" ",s=""){for(;t.hasNext();)s+=`${t.next()}${e}`;return s}class a{constructor(t){this.current=t}hasNext(){return o.echt(this.current)}remove(){throw Error("Unsupported")}next(){if(!this.hasNext())throw Error("NoSuchElementException");let t=this.current.item;return this.current=this.current.next,t}}function c(t,e){return{item:t,next:e}}class u{constructor(){this.first=e,this.n=0}clone(){let t,e=new u,s=this.first;for(;s;)t?(t.next=c(s.item),t=t.next):e.first=t=c(s.item),e.n+=1,s=s.next;return e}isEmpty(){return o.nichts(this.first)}size(){return this.n}add(t){this.first=c(t,this.first),this.n+=1}iter(){return new a(this.first)}static test(){let t=new u;"to be or not to - be - - that - - - is".split(" ").forEach((e=>t.add(e))),console.log("size of bag = "+t.size()),console.log(l(t.iter()));let e=t.clone();console.log("size of cloned = "+e.size()),console.log(l(e.iter()))}}class d{constructor(){this.first=e,this.n=0}clone(){let t,e=new d,s=this.first;for(;s;)t?(t.next=c(s.item),t=t.next):e.first=t=c(s.item),e.n+=1,s=s.next;return e}isEmpty(){return o.nichts(this.first)}size(){return this.n}push(t){this.first=c(t,this.first),this.n+=1}pop(){if(this.isEmpty())throw Error("Stack underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,t}peek(){if(this.isEmpty())throw Error("Stack underflow");return this.first.item}toString(){return l(this.iter())}iter(){return new a(this.first)}static test(){let t=new d;"to be or not to - be - - that - - - is".split(" ").forEach((e=>{"-"!=e?t.push(e):t.isEmpty()||console.log("(-)"+t.pop()+" ")})),console.log("("+t.size()+" left on stack)");let e=t.clone();console.log("cloned= "+l(e.iter())),console.log("("+e.size()+" left on stack)")}}class f{constructor(){this.first=e,this.last=e,this.n=0}clone(){let t=new f,e=this.first;for(;e;)t.enqueue(e.item),e=e.next;return t}isEmpty(){return o.nichts(this.first)}size(){return this.n}peek(){if(this.isEmpty())throw Error("Queue underflow");return this.first.item}enqueue(t){let e=this.last;this.last=c(t),this.isEmpty()?this.first=this.last:e.next=this.last,this.n+=1}dequeue(){if(this.isEmpty())throw Error("Queue underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,this.isEmpty()&&(this.last=e),t}toString(){return l(this.iter())}iter(){return new a(this.first)}static test(){let t=new f;"to be or not to - be - - that - - - is".split(/\s+/).forEach((e=>{"-"!=e?t.enqueue(e):t.isEmpty()||console.log(t.dequeue()+" ")})),console.log("("+t.size()+" left on queue)");let e=t.clone();console.log("cloned= "+l(e.iter())),console.log("("+e.size()+" left on queue)")}}class g{constructor(t){this.compare=t||i,this.root=e,this.n=0}size(){return this.n}contains(t){return void 0!==this.get(t)}get(t){const e=(t,s,i)=>{if(s){let r=this.compare(t,s.key);i=r<0?e(t,s.left):r>0?e(t,s.right):s.value}return i};if(h(t)&&this.n>0)return e(t,this.root)}set(t,e){const s=(t,e,i)=>{if(!i)return this.n+=1,{key:t,value:e};let r=this.compare(t,i.key);return r<0?i.left=s(t,e,i.left):r>0?i.right=s(t,e,i.right):i.value=e,i};h(t)&&void 0!==e&&(this.root=s(t,e,this.root))}_getMaxNode(t){for(;t&&t.right;)t=t.right;return t}_getMaxKey(){let t=this._getMaxNode(this.root);if(t)return t.key}_getMinNode(t){for(;t&&t.left;)t=t.left;return t}_getMinKey(){let t=this._getMinNode(this.root);if(t)return t.key}remove(t){const s=(t,i)=>{if(i){let r,n,o,h=this.compare(t,i.key);h<0?i.left=s(t,i.left):h>0?i.right=s(t,i.right):i.left&&i.right?(o=this._getMaxNode(i.left),r=o.key,n=o.value,o.value=i.value,o.key=i.key,i.key=r,i.value=n,i.left=s(t,i.left)):i.left?(i=i.left,this.n-=1):i.right?(i=i.right,this.n-=1):(i=e,this.n-=1)}return i};h(t)&&(this.root=s(t,this.root))}keys(){let t=new f;return this.forEach(((e,s)=>t.enqueue(s))),t.iter()}firstKey(){let t;try{this.forEach(((e,s)=>{throw t=s,Error("????")}))}catch(t){}return t}lastKey(){let t;return this.forEach(((e,s)=>{t=s})),t}forEach(t,e){function s(t,e){return e&&e.apply(t,Array.prototype.slice.call(arguments,2))}!function t(e,i,r,n){if(!e)return s(r,n);t(e.left,i,r,(function(){s(r,i,e.value,e.key),t(e.right,i,r,(function(){s(r,n)}))}))}(this.root,t,e)}static test(){let t=new g;t.set(3,"3"),t.set(2,"2"),t.set(7,"7"),t.set(1,"1"),console.log(`firstKey= ${t.firstKey()}`),console.log(`lastKey= ${t.lastKey()}`),console.log(l(t.keys())),console.log(`k= ${t.get(3)}`),console.log(`has 2 = ${t.contains(2)}`),console.log(`has size = ${t.size()}`),t.remove(1),console.log(`has size = ${t.size()}`),console.log(l(t.keys())),console.log(`k= ${t.get(2)}`)}}class p{constructor(){this.st=new g}get(t){if(o.nichts(t))throw Error("calls get() with null key");return this.st.get(t)}put(t,e){if(o.nichts(t))throw Error("calls put() with null key");void 0===e?this.st.remove(t):this.st.set(t,e)}remove(t){if(o.nichts(t))throw Error("calls remove() with null key");this.st.remove(t)}contains(t){if(o.nichts(t))throw Error("calls contains() with null key");return this.st.contains(t)}size(){return this.st.size()}isEmpty(){return 0==this.size()}keys(){return this.st.keys()}min(){if(this.isEmpty())throw Error("calls min() with empty symbol table");return this.st.firstKey()}max(){if(this.isEmpty())throw Error("calls max() with empty symbol table");return this.st.lastKey()}ceiling(t){if(o.nichts(t))throw Error("argument to ceiling() is null");let e,s,i=this.st.keys();for(;i.hasNext();)if(s=i.next(),s==t||s>t){e=s;break}if(void 0===e)throw Error("argument to ceiling() is too large");return e}floor(t){if(o.nichts(t))throw Error("argument to floor() is null");let e,s,i=this.st.keys();for(;i.hasNext();)s=i.next(),(s==t||s<t)&&(e=s);if(void 0===e)throw Error("argument to floor() is too small");return e}static test(){let t=new p;t.put("a",1),t.put("g",9),t.put("c",3),t.put("j",10),t.put("z",26),t.put("x",24),console.log(`isEmpty= ${t.isEmpty()}`),console.log(`size= ${t.size()}`),console.log(`get-c= ${t.get("c")}`),console.log(`contains z= ${t.contains("z")}`),console.log(`contains m= ${t.contains("m")}`),console.log(l(t.keys())),console.log(`ceil w= ${t.ceiling("w")}`),console.log(`floor k= ${t.floor("k")}`),console.log(`min = ${t.min()}`),console.log(`max = ${t.max()}`),t.remove("x"),console.log(l(t.keys()))}}class m{static M=4;Node(t){return{m:t,children:new Array(m.M)}}Entry(t,e,s){return{key:t,val:e,next:s}}constructor(t){this.root=this.Node(0),this.compare=t,this._height=0,this.n=0}isEmpty(){return 0==this.size()}size(){return this.n}height(){return this._height}get(t){if(o.nichts(t))throw Error("argument to get() is null");return this._search(this.root,t,this._height)}_search(t,e,s){let i=t.children;if(0==s){for(let s=0;s<t.m;++s)if(0==this.compare(e,i[s].key))return i[s].val}else for(let r=0;r<t.m;++r)if(r+1==t.m||this.compare(e,i[r+1].key)<0)return this._search(i[r].next,e,s-1)}put(t,e){if(o.nichts(t))throw Error("argument key to put() is null");let s,i=this._insert(this.root,t,e,this._height);this.n+=1,i&&(s=this.Node(2),s.children[0]=this.Entry(this.root.children[0].key,null,this.root),s.children[1]=this.Entry(i.children[0].key,null,i),this.root=s,this._height+=1)}_insert(t,e,s,i){let r,n=this.Entry(e,s);if(0==i)for(r=0;r<t.m&&!(this.compare(e,t.children[r].key)<0);++r);else for(r=0;r<t.m;++r)if(r+1==t.m||this.compare(e,t.children[r+1].key)<0){let o=this._insert(t.children[r++].next,e,s,i-1);if(!o)return null;n.key=o.children[0].key,n.val=null,n.next=o;break}for(let e=t.m;e>r;--e)t.children[e]=t.children[e-1];if(t.children[r]=n,t.m++,t.m>=m.M)return this._split(t)}_split(t){let e=r(m.M/2),s=this.Node(e);t.m=e;for(let i=0;i<e;++i)s.children[i]=t.children[e+i];return s}toString(){return function t(e,s,i){let r="",n=e.children;if(0==s)for(let t=0;t<e.m;++t)r+=`${i}${n[t].key} ${n[t].val}\n`;else for(let o=0;o<e.m;++o)o>0&&(r+=`${i}(${n[o].key})\n`),r+=t(n[o].next,s-1,i+"     ");return r}(this.root,this._height,"")+"\n"}static test(){let t=new m(i);t.put("www.cs.princeton.edu","128.112.136.12"),t.put("www.cs.princeton.edu","128.112.136.11"),t.put("www.princeton.edu","128.112.128.15"),t.put("www.yale.edu","130.132.143.21"),t.put("www.simpsons.com","209.052.165.60"),t.put("www.apple.com","17.112.152.32"),t.put("www.amazon.com","207.171.182.16"),t.put("www.ebay.com","66.135.192.87"),t.put("www.cnn.com","64.236.16.20"),t.put("www.google.com","216.239.41.99"),t.put("www.nytimes.com","199.239.136.200"),t.put("www.microsoft.com","207.126.99.140"),t.put("www.dell.com","143.166.224.230"),t.put("www.slashdot.org","66.35.250.151"),t.put("www.espn.com","199.181.135.201"),t.put("www.weather.com","63.111.66.11"),t.put("www.yahoo.com","216.109.118.65"),console.log("cs.princeton.edu:  "+t.get("www.cs.princeton.edu")),console.log("hardvardsucks.com: "+t.get("www.harvardsucks.com")),console.log("simpsons.com:      "+t.get("www.simpsons.com")),console.log("apple.com:         "+t.get("www.apple.com")),console.log("ebay.com:          "+t.get("www.ebay.com")),console.log("dell.com:          "+t.get("www.dell.com")),console.log(""),console.log("size:    "+t.size()),console.log("height:  "+t.height()),console.log(t.toString()),console.log("")}}class y{constructor(t){this.d=t,this.st=new p}put(t,e){if(t<0||t>=this.d)throw Error("Illegal index");o.feq0(e)?this.st.remove(t):this.st.put(t,e)}get(t){if(t<0||t>=this.d)throw Error("Illegal index");return this.st.contains(t)?this.st.get(t):0}nnz(){return this.st.size()}dimension(){return this.d}dot(t){if(o.assert(t instanceof y,"expected SparseVector data"),this.d!=t.d)throw Error("Vector lengths disagree");let e,s=0,i=(this.st.size()<=t.st.size()?this:t).st.keys();for(;i.hasNext();)e=i.next(),t.st.contains(e)&&(s+=this.get(e)*t.get(e));return s}dotWith(t){let e=0;for(let s,i=this.st.keys();i.hasNext();)s=i.next(),e+=t[s]*this.get(s);return e}magnitude(){return Math.sqrt(this.dot(this))}scale(t){let e=new y(this.d);for(let s,i=this.st.keys();i.hasNext();)s=i.next(),e.put(s,t*this.get(s));return e}plus(t){if(o.assert(t instanceof y,"expected SparseVector data"),this.d!=t.d)throw Error("Vector lengths disagree");let e=new y(this.d);for(let t,s=this.st.keys();s.hasNext();)t=s.next(),e.put(t,this.get(t));for(let s,i=t.st.keys();i.hasNext();)s=i.next(),e.put(s,t.get(s)+e.get(s));return e}toString(){let t="";for(let e,s=this.st.keys();s.hasNext();)e=s.next(),t+=`(${e}, ${this.st.get(e)}) `;return t}static test(){let t=new y(10),e=new y(10);t.put(3,.5),t.put(9,.75),t.put(6,.11),t.put(6,0),e.put(3,.6),e.put(4,.9),console.log("a = "+t.toString()),console.log("b = "+e.toString()),console.log("a dot b = "+t.dot(e)),console.log("a + b   = "+t.plus(e).toString())}}return{prnIter:l,StdCompare:i,BTree:m,Bag:u,Stack:d,Queue:f,ST:p,TreeMap:g,SparseVector:y,Iterator:a}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core")):t["io/czlab/mcfud/algo/basic"]=s}(this),function(t,e){"use strict";function s(s,i,r){s||(s=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/math"]()),r||(r=t["io/czlab/mcfud/algo/basic"]());const{prnIter:n,Bag:o,Stack:h,Iterator:l,StdCompare:a}=r,c=Math.floor,{is:u,u:d}=s;function f(t,e,s,i,r){d.assert(t>e,"bad resize capacity");let n,o=new Array(t);for(n=s;n<i;++n)o[n]=r[n];return o}const g=(t,e,s)=>s(t,e)<0;function p(t,e,s){const i=t[e];t[e]=t[s],t[s]=i}function m(t){let e,s="";for(e=0;e<t.length;++e)s+=`${t[e]} `;console.log(s)}class y{static sort(t,e){const s=t.length;for(let i=1;i<s;++i)for(let s=i;s>0&&g(t[s],t[s-1],e);--s)p(t,s,s-1);return t}static sortRange(t,e,s,i){for(let r=e+1;r<s;++r)for(let s=r;s>e&&g(t[s],t[s-1],i);--s)p(t,s,s-1);return t}static indexSort(t,e){const s=t.length,i=d.fill(s,(t=>t));for(let r=1;r<s;++r)for(let s=r;s>0&&g(t[i[s]],t[i[s-1]],e);--s)p(i,s,s-1);return i}static test(){let t="SORTEXAMPLE".split("");m(y.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(y.sortRange(t,0,t.length,a)),t="SORTEXAMPLE".split(""),m(y.indexSort(t,a))}}class _{static sort(t,e){let s,r,n,o=t.length;for(let h,l=1;l<o;++l){for(r=0,n=l,h=t[l];r<n;)s=r+i.ndiv(n-r,2),g(h,t[s],e)?n=s:r=s+1;for(let e=l;e>r;--e)t[e]=t[e-1];t[r]=h}return t}static test(){let t="SORTEXAMPLE".split("");m(_.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(_.sort(t,a))}}class w{static sort(t,e){let s,i=t.length;for(let r=0;r<i;++r){s=r;for(let n=r+1;n<i;++n)g(t[n],t[s],e)&&(s=n);p(t,r,s)}return t}static test(){let t="SORTEXAMPLE".split("");m(w.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(w.sort(t,a))}}class N{static sort(t,e){let s=t.length,r=1,n=i.ndiv(s,3);for(;r<n;)r=3*r+1;for(;r>=1;){for(let i=r;i<s;++i)for(let s=i;s>=r&&g(t[s],t[s-r],e);s-=r)p(t,s,s-r);r=i.ndiv(r,3)}return t}static test(){let t="SORTEXAMPLE".split("");m(N.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(N.sort(t,a))}}function k(t,e,s,r,n,o){if(n<=r);else{let h=r+i.ndiv(n-r,2);k(t,e,s,r,h,o),k(t,e,s,h+1,n,o),function(t,e,s,i,r,n,o){for(let t=i;t<=n;++t)s[t]=e[t];let h=i,l=r+1;for(let a=i;a<=n;++a)h>r?e[a]=s[l++]:l>n?e[a]=s[h++]:g(t[s[l]],t[s[h]],o)?e[a]=s[l++]:e[a]=s[h++]}(t,e,s,r,h,n,o)}return t}class v{static sort(t,e){return function t(e,s,r,n,o){if(n<=r);else{let h=r+i.ndiv(n-r,2);t(e,s,r,h,o),t(e,s,h+1,n,o),function(t,e,s,i,r,n){for(let i=s;i<=r;++i)e[i]=t[i];let o=s,h=i+1;for(let l=s;l<=r;++l)o>i?t[l]=e[h++]:h>r?t[l]=e[o++]:g(e[h],e[o],n)?t[l]=e[h++]:t[l]=e[o++]}(e,s,r,h,n,o)}return e}(t,new Array(t.length),0,t.length-1,e),t}static indexSort(t,e){let s=t.length,i=d.fill(s,(t=>t));return k(t,i,new Array(s),0,s-1,e),i}static test(){let t="SORTEXAMPLE".split("");m(v.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(v.sort(t,a)),t="SORTEXAMPLE".split(""),m(v.indexSort(t,a))}}class x{static sort(t,e){const s=t.length;for(let i,r=0;r<s;++r){i=0;for(let n=s-1;n>r;--n)g(t[n],t[n-1],e)&&(p(t,n,n-1),++i);if(0==i)break}return t}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");x.sort(t,a),m(t)}}function E(t,e,s,i){let r=e,n=t[e],o=s+1;for(;;){for(;g(t[++r],n,i)&&r!=s;);for(;g(n,t[--o],i)&&o!=e;);if(r>=o)break;p(t,r,o)}return p(t,e,o),o}class b{static sort(t,e){return function t(e,s,i,r){if(i<=s);else{let n=E(e,s,i,r);t(e,s,n-1,r),t(e,n+1,i,r)}return e}(t,0,t.length-1,e),t}static select(t,e,s){if(e<0||e>=t.length)throw Error(`index is not between 0 and ${t.length}: ${e}`);let i=0,r=t.length-1;for(;r>i;){let n=E(t,i,r,s);if(n>e)r=n-1;else{if(!(n<e))return t[n];i=n+1}}return t[i]}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");m(b.sort(t,a)),t="SORTEXAMPLE".split(""),m(b.sort(t,a)),d.shuffle(t),t.forEach(((e,s)=>console.log(b.select(t,s,a))))}}const T=(t,e,s,i)=>g(t[e],t[s],i);class M{Node(t){return{key:t,order:0}}constructor(t,s){this.compare=t,this.table=new Map,this.head=e,this._min=e,this.n=0,u.vec(s)&&s.forEach((t=>this.insert(t)))}isEmpty(){return 0==this.n}size(){return this.n}insert(t){let e=this.Node(t);this.n+=1,this.head=this._insertNode(e,this.head),this._min=this._min?this._greater(this._min.key,t)?this.head:this._min:this.head}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cut(this._min,this.head);let t=this._min.child,s=this._min.key;return this._min.key=e,t&&(this.head=this._meld(this.head,t),this._min.child=e),this.n-=1,this.isEmpty()?this._min=e:this._consolidate(),s}union(t){return this.head=this._meld(this.head,t.head),this._min=this._greater(this._min.key,t._min.key)?t._min:this._min,this.n=this.n+t.n,this}_greater(t,e){return!d.nichts(t)&&(!!d.nichts(e)||this.compare(t,e)>0)}_link(t,e){e.child=this._insertNode(t,e.child),e.order+=1}_consolidate(){this.table.clear();let t=this.head,s=e,i=e,r=0;this._min=this.head;do{for(s=t,t=t.next,i=this.table.get(s.order);i;)this.table.delete(s.order),this._greater(s.key,i.key)?(this._link(s,i),s=i):this._link(i,s),i=this.table.get(s.order);this.table.set(s.order,s),s.order>r&&(r=s.order)}while(t!==this.head);this.head=null,this.table.forEach((t=>{t&&(this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head))}))}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cut(t,s){if(t.next===t)return t.next=e,t.prev=e,e;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=e,t.prev=e,s===t?i:s}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new M(this.compare),e=s=>{if(!s)return;let i=s;do{t.insert(i.key),e(i.child),i=i.next}while(i!==s)};return e(this.head),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new M(a);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ",e.isEmpty(),console.log(t),console.log("min= "+e.min()),console.log(n(e.iter())),console.log("("+e.size()+" left on pq)");let s=new M(a);"ZTAK".split("").forEach((t=>s.insert(t))),s=s.union(e),console.log(n(s.iter()))}}class I{Node(t){return{key:t,order:0,index:0}}constructor(t,s){if(t<0)throw Error("Cannot create a priority queue of negative size");this.maxN=t,this.n=0,this.head=e,this._min=e,this.compare=s,this.table=new Map,this.nodes=new Array(t)}isEmpty(){return 0==this.n}contains(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");return d.echt(this.nodes[t])}size(){return this.n}insert(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(this.contains(t))throw Error("Specified index is already in the queue");let s=this.Node(e);s.index=t,this.nodes[t]=s,this.n+=1,this.head=this._insertNode(s,this.head),this._min=this._min?this._greater(this._min.key,e)?this.head:this._min:this.head}minIndex(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.index}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cutNode(this._min,this.head);let t=this._min.child,s=this._min.index;if(this._min.key=e,t){do{t.parent=e,t=t.next}while(t!==this._min.child);this.head=this._meld(this.head,t),this._min.child=e}return this.n-=1,this.isEmpty()?this._min=e:this._consolidate(),this.nodes[s]=e,s}keyOf(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");return this.nodes[t].key}changeKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");this._greater(e,this.nodes[t].key)?this.increaseKey(t,e):this.decreaseKey(t,e)}decreaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(e,this.nodes[t].key))throw Error("Calling with this argument would not decrease the key");let s=this.nodes[t];s.key=e,this._greater(this._min.key,e)&&(this._min=s),s.parent&&this._greater(s.parent.key,e)&&this._cut(t)}increaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(this.nodes[t].key,e))throw Error("Calling with this argument would not increase the key");this.delete(t),this.insert(t,e)}delete(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");let s=this.nodes[t];if(s.key=null,s.parent&&this._cut(t),this.head=this._cutNode(s,this.head),s.child){let t=s.child;s.child=e,s=t;do{t.parent=e,t=t.next}while(t!==s);this.head=this._meld(this.head,t)}this.isEmpty()?this._min=e:this._consolidate(),this.nodes[t]=e,this.n-=1}_greater(t,e){return!d.nichts(t)&&(!!d.nichts(e)||this.compare(t,e)>0)}_link(t,e){t.parent=e,e.child=this._insertNode(t,e.child),e.order+=1}_cut(t){let s=this.nodes[t],i=s.parent;i.child=this._cutNode(s,i.child),s.parent=e,i.order-=1,this.head=this._insertNode(s,this.head),i.mark=!i.mark,!i.mark&&i.parent&&this._cut(i.index)}_consolidate(){let t=e,s=e,i=0,r=this.head;this.table.clear(),this._min=this.head;do{for(t=r,r=r.next,s=this.table.get(t.order);s;)this.table.delete(t.order),this._greater(t.key,s.key)?(this._link(t,s),t=s):this._link(s,t),s=this.table.get(t.order);this.table.set(t.order,t),t.order>i&&(i=t.order)}while(r!==this.head);this.head=e,this.table.forEach((t=>{this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head)}))}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cutNode(t,s){if(t.next===t)return t.next=e,t.prev=e,e;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=e,t.prev=e,s===t?i:s}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new I(this.maxN,this.compare);return this.nodes.forEach((e=>{e&&t.insert(e.index,e.key)})),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new I(t.length,a);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(console.log("min= "+e.min()),console.log("minindex= "+e.minIndex()),console.log("size= "+e.size()),console.log("contains(3)="+e.contains(3)),console.log("keyOf(3)="+e.keyOf(3)),e.changeKey(3,"bbbb");!e.isEmpty();){let t=e.minIndex();console.log(t+" "+e.keyOf(t)),e.delMin()}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class S{constructor(t,e){if(this.comparator=t,this.n=0,u.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=c(this.n/2);t>=1;--t)this._sink(t,this)}else this.pq=new Array(u.num(e)?e:2);d.assert(this._isMinHeap(),"not min heap")}isEmpty(){return 0==this.n}size(){return this.n}min(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=f(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.pq[++this.n]=t,this._swim(this.n),d.assert(this._isMinHeap(),"not min heap-insert")}delMin(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return p(this.pq,1,this.n--),this._sink(1),this.pq[this.n+1]=e,this.n>0&&this.n==i.ndiv(this.pq.length-1,4)&&(this.pq=f(i.ndiv(this.pq.length,2),this.n,1,this.n+1,this.pq)),t}_swim(t){for(;t>1&&this._greater(i.ndiv(t,2),t);)p(this.pq,t,i.ndiv(t,2)),t=i.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&e++,!this._greater(t,e))break;p(this.pq,t,e),t=e}}_greater(t,e){return this.comparator(this.pq[t],this.pq[e])>0}_isMinHeap(){for(let t=1;t<=this.n;++t)if(d.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(!d.nichts(this.pq[t]))return!1;return!d.echt(this.pq[0])&&this._isMinHeapOrdered(1)}_isMinHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&this._greater(t,e))&&(!(s<=this.n&&this._greater(t,s))&&(this._isMinHeapOrdered(e)&&this._isMinHeapOrdered(s)))}iter(){let t=new S(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new S(a);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}class O{constructor(t,e){if(this.comparator=t,this.n=0,u.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=c(this.n/2);t>=1;--t)this._sink(t)}else this.pq=new Array(u.num(e)?e:2);d.assert(this._isMaxHeap(),"not max heap")}isEmpty(){return 0==this.n}size(){return this.n}max(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=f(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.n+=1,this.pq[this.n]=t,this._swim(this.n),d.assert(this._isMaxHeap(),"not max heap-insert")}delMax(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return p(this.pq,1,this.n),this.n-=1,this._sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==i.ndiv(this.pq.length-1,4)&&(this.pq=f(i.ndiv(this.pq.length,2),this.n,1,this.n+1,this.pq)),t}_isMaxHeap(){for(let t=1;t<=this.n;++t)if(d.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(d.echt(this.pq[t]))return!1;return!d.echt(this.pq[0])&&this._isMaxHeapOrdered(1)}_isMaxHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&T(this.pq,t,e,this.comparator))&&(!(s<=this.n&&T(this.pq,t,s,this.comparator))&&(this._isMaxHeapOrdered(e)&&this._isMaxHeapOrdered(s)))}_swim(t){for(;t>1&&T(this.pq,i.ndiv(t,2),t,this.comparator);)p(this.pq,t,i.ndiv(t,2)),t=i.ndiv(t,2)}_sink(t){let e;for(;2*t<=this.n&&(e=2*t,e<this.n&&T(this.pq,e,e+1,this.comparator)&&++e,T(this.pq,t,e,this.comparator));)p(this.pq,t,e),t=e}iter(){const t=new O(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t="",e=new O(a);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}function q(t,e,s,i){return i(t[e-1],t[s-1])<0}function z(t,e,s){const i=t[e-1];t[e-1]=t[s-1],t[s-1]=i}class A{static sort(t,e){function s(t,e,s,i){for(;2*e<=s;){let r=2*e;if(r<s&&q(t,r,r+1,i)&&++r,!q(t,e,r,i))break;z(t,e,r),e=r}}let r,n=t.length;for(r=i.ndiv(n,2);r>=1;--r)s(t,r,n,e);for(r=n;r>1;)z(t,1,r--),s(t,1,r,e);return t}static test(){let t="SORTEXAMPLE".split("");m(A.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(A.sort(t,a))}}class R{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}minIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}minKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMin(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),d.assert(t==this.pq[this.n+1],"No good"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(s<0)throw Error("Calling decreaseKey() with a key strictly greater than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(s>0)throw Error("Calling increaseKey() with a key strictly less than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.qp[t];this._exch(s,this.n--),this._swim(s),this._sink(s),this.mKeys[t]=e,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_greater(t,e){return this.compare(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]])>0}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._greater(i.ndiv(t,2),t);)this._exch(t,i.ndiv(t,2)),t=i.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&++e,!this._greater(t,e))break;this._exch(t,e),t=e}}iter(){let t=new R(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new R(t.length,a);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(;!e.isEmpty();){let s=e.delMin();console.log(s+" "+t[s])}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class D{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}maxIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}maxKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMax(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),d.assert(this.pq[this.n+1]==t,"bad delMax"),this.qp[t]=-1,this.mKeys[t]=e,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)>0)throw Error("Calling increaseKey() with a key that is strictly less than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)<0)throw Error("Calling decreaseKey() with a key that is strictly greater than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.qp[t];this._exch(s,this.n--),this._swim(s),this._sink(s),this.mKeys[t]=e,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_less(t,e){return g(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]],this.compare)}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._less(i.ndiv(t,2),t);)this._exch(t,i.ndiv(t,2)),t=i.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._less(e,e+1)&&++e,!this._less(t,e))break;this._exch(t,e),t=e}}iter(){let t=new D(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new D(t.length,a);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);console.log("");for(let s=0;s<t.length;++s)d.rand()<.5?e.increaseKey(s,t[s]+t[s]):e.decreaseKey(s,t[s].substring(0,1));for(;!e.isEmpty();){let t=e.maxKey(),s=e.delMax();console.log(s+" "+t)}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);let s=new Array(t.length);for(let e=0;e<t.length;++e)s[e]=e;d.shuffle(s);for(let t=0;t<s.length;++t){let i=e.keyOf(s[t]);e.delete(s[t]),console.log(s[t]+" "+i)}}}return{FibonacciMinPQ:M,IndexFibonacciMinPQ:I,Insertion:y,BinaryInsertion:_,Selection:w,Shell:N,Merge:v,Bubble:x,Quick:b,MinPQ:S,MaxPQ:O,Heap:A,IndexMinPQ:R,IndexMaxPQ:D}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core"),require("../main/math"),require("./basic")):t["io/czlab/mcfud/algo/sort"]=s}(this),function(t,e){"use strict";function s(s,i,r,n){s||(s=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/math"]()),r||(r=t["io/czlab/mcfud/algo/basic"]()),n||(n=t["io/czlab/mcfud/algo/sort"]());const{Bag:o,Stack:h,Queue:l,StdCompare:a,prnIter:c}=r,{MinPQ:u}=n,{is:d,u:f}=(Math.floor,s);class g{static count(t,e){let s=new Map,i=0,r="",n=0;for(let r,o=0;o<t.length;++o)r=t[o],r.length<e||(++i,s.has(r)?s.set(r,s.get(r)+1):(s.set(r,1),++n));return s.set(r,0),Array.from(s.keys()).forEach((t=>{s.get(t)>s.get(r)&&(r=t)})),[r,s.get(r),[n,i]]}static test(){let t="it was the best of times it was the worst of times\n        it was the age of wisdom it was the age of foolishness\n        it was the epoch of belief it was the epoch of incredulity\n        it was the season of light it was the season of darkness\n        it was the spring of hope it was the winter of despair".split(" "),[e,s,i]=g.count(t,1);console.log(e+" "+s),console.log("distinct = "+i[0]),console.log("words= "+i[1])}}class p{constructor(){this.first=e,this.n=0}size(){return this.n}isEmpty(){return 0==this.size()}contains(t){if(f.nichts(t))throw Error("argument to contains is null");return void 0!==this.get(t)}get(t){if(f.nichts(t))throw Error("argument to get is null");for(let e=this.first;e;e=e.next)if(t==e.key)return e.val}put(t,e){if(f.nichts(t))throw Error("first argument to put is null");if(void 0===e)this.delete(t);else{let s,i;for(i=this.first;i&&!s;i=i.next)t==i.key&&(i.val=e,s=!0);s||(this.first=((t,e,s)=>({key:t,val:e,next:s}))(t,e,this.first),this.n+=1)}}delete(t){const s=(t,i)=>t?i==t.key?(this.n-=1,t.next):(t.next=s(t.next,i),t):e;if(f.nichts(t))throw Error("argument to delete is null");this.first=s(this.first,t)}keys(){let t=new l;for(let e=this.first;e;e=e.next)t.enqueue(e.key);return t.iter()}static load(t){let e=new p;return t.forEach(((t,s)=>e.put(t,s))),e}static test(){let t=p.load("SEARCHEXAMPLE".split(""));console.log(((e="",s=0,i=0)=>{for(i=t.keys();i.hasNext();)e+=`${s=i.next()}=${t.get(s)} `;return e})()),console.log("size= "+t.size()),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),t.delete("R"),t.isEmpty(),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),console.log("size= "+t.size())}}class m{constructor(t,e=2){this.mKeys=new Array(e),this.vals=new Array(e),this.compare=t,this.n=0,this._resize=t=>{let e=new Array(t),s=new Array(t);for(let t=0;t<this.n;++t)e[t]=this.mKeys[t],s[t]=this.vals[t];this.vals=s,this.mKeys=e},this._argOk=t=>f.echt(t,"Invalid argument"),this._check=()=>(()=>{for(let t=1;t<this.size();++t)if(this.compare(this.mKeys[t],this.mKeys[t-1])<0)return!1;return!0})()&&(()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t=0;t<this.size();++t)if(0!=this.compare(this.mKeys[t],this.select(this.rank(this.mKeys[t]))))return!1;return!0})()}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){if(this._argOk(t)&&!this.isEmpty()){let e=this.rank(t);if(e<this.n&&0==this.compare(this.mKeys[e],t))return this.vals[e]}}rank(t){let e,s,r=0,n=this.n-1;for(this._argOk(t);r<=n;)if(e=r+i.ndiv(n-r,2),s=this.compare(t,this.mKeys[e]),s<0)n=e-1;else{if(!(s>0))return e;r=e+1}return r}put(t,e){if(this._argOk(t)&&void 0===e)this.delete(t);else{let s=this.rank(t);if(s<this.n&&0==this.compare(this.mKeys[s],t))this.vals[s]=e;else{this.n==this.mKeys.length&&this._resize(2*this.mKeys.length);for(let t=this.n;t>s;--t)this.mKeys[t]=this.mKeys[t-1],this.vals[t]=this.vals[t-1];this.n+=1,this.mKeys[s]=t,this.vals[s]=e}}}delete(t){if(this._argOk(t)&&this.isEmpty());else{let s=this.rank(t);if(s==this.n||0!=this.compare(this.mKeys[s],t));else{for(let t=s;t<this.n-1;++t)this.mKeys[t]=this.mKeys[t+1],this.vals[t]=this.vals[t+1];this.n-=1,this.mKeys[this.n]=e,this.vals[this.n]=e,this.n>0&&this.n==i.ndiv(this.mKeys.length,4)&&this._resize(i.ndiv(this.mKeys.length,2)),this._check()}}}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.min())}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.max())}min(){if(this.isEmpty())throw Error("called min with empty symbol table");return this.mKeys[0]}max(){if(this.isEmpty())throw Error("called max with empty symbol table");return this.mKeys[this.n-1]}select(t){if(t<0||t>=this.size())throw Error(`called select with invalid argument: ${t}`);return this.mKeys[t]}floor(t){let e=this._argOk(t)&&this.rank(t);if(e<this.n&&0==this.compare(t,this.mKeys[e]))return this.mKeys[e];if(0==e)throw Error("argument to floor is too small");return this.mKeys[e-1]}ceiling(t){let e=this._argOk(t)&&this.rank(t);if(e==this.n)throw Error("argument to ceiling is too large");return this.mKeys[e]}size(t,e){return 0==arguments.length?this.n:(this._argOk(t)&&this._argOk(e),this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t))}keys(t,e){0==arguments.length&&(t=this.min(),e=this.max()),this._argOk(t)&&this._argOk(e);let s=new l;if(this.compare(t,e)>0);else{for(let i=this.rank(t);i<this.rank(e);++i)s.enqueue(this.mKeys[i]);this.contains(e)&&s.enqueue(this.mKeys[this.rank(e)])}return s.iter()}static load(t,e){let s=new m(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t=m.load("SEARCHEXAMPLE".split(""),a),e=e=>{e="";for(let s,i=t.keys();i.hasNext();)s=i.next(),e+=`${s}=${t.get(s)} `;return e};console.log(e()),t.deleteMin(),console.log(e()),t.deleteMax(),t.isEmpty(),console.log(e()),console.log("floor of Q= "+t.floor("Q")),console.log("ceil of Q= "+t.ceiling("Q")),console.log("size= "+t.size()),console.log("size= "+t.size("E","P")),console.log("keys E->P = "+c(t.keys("E","P")))}}class y{constructor(t){this.compare=t,this.root=e,this._argOk=t=>f.assert(t,"Invalid argument"),this._check=()=>(this.isBST(this.root,null,null)||console.log("Not in symmetric order"),this.isSizeConsistent(this.root)||console.log("Subtree counts not consistent"),this.isRankConsistent()||console.log("Ranks not consistent"),this.isBST(this.root,null,null)&&this.isSizeConsistent(this.root)&&this.isRankConsistent()),this.isBST=(t,e,s)=>!!f.nichts(t)||!(f.echt(e)&&this.compare(t.key,e)<=0)&&(!(f.echt(s)&&this.compare(t.key,s)>=0)&&(this.isBST(t.left,e,t.key)&&this.isBST(t.right,t.key,s))),this.isSizeConsistent=t=>!!f.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(this.isSizeConsistent(t.left)&&this.isSizeConsistent(t.right)),this.isRankConsistent=()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this.rank(t))))return!1;return!0}}Node(t,e,s){return{key:t,val:e,size:s}}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){return this._getNode(this.root,t)}_getNode(t,e){if(!this._argOk(e)||!f.nichts(t)){let s=this.compare(e,t.key);return s<0?this._getNode(t.left,e):s>0?this._getNode(t.right,e):t.val}}put(t,e){this._argOk(t)&&f.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this._check())}_putNode(t,e,s){if(f.nichts(t))t=this.Node(e,s,1);else{let i=this.compare(e,t.key);i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right)}return t}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMinNode(this.root),this._check()}_deleteMinNode(t){return f.nichts(t.left)?t=t.right:(t.left=this._deleteMinNode(t.left),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMaxNode(this.root),this._check()}_deleteMaxNode(t){return f.nichts(t.right)?t=t.left:(t.right=this._deleteMaxNode(t.right),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}delete(t){this.root=this._argOk(t)&&this._deleteNode(this.root,t),this._check()}_deleteNode(t,e){if(f.echt(t)){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(f.nichts(t.right))return t.left;if(f.nichts(t.left))return t.right;let e=t;(t=this._minNode(e.right)).right=this._deleteMinNode(e.right),t.left=e.left}t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1}return t}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return f.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return f.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(f.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s<0)return this._floorNode(t.left,e);let i=this._floorNode(t.right,e);return f.nichts(i)?t:i}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too large");return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0){let e=this._ceilingNode(t.left,s);return e||t}return this._ceilingNode(t.right,s)}select(t){if(t<0||t>=this.size())throw Error(`argument to select is invalid: ${t}`);return this._selectNode(this.root,t)}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new l;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(f.nichts(t));else{let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}return e}_sizeNode(t){return f.nichts(t)?0:t.size}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}height(){return this._heightNode(this.root)}_heightNode(t){return f.nichts(t)?-1:1+Math.max(this._heightNode(t.left),this._heightNode(t.right))}levelOrder(){let t,e=[],s=new l;for(e.push(this.root);e.length>0;)t=e.pop(),f.echt(t)&&(s.enqueue(t.key),e.push(t.left,t.right));return s.iter()}static load(t,e){let s=new y(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t,e=y.load("SEARCHEXAMPLE".split(""),a);t="";for(let s,i=e.levelOrder();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("level-order:\n"+t),t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;e.isEmpty(),console.log("keys=\n"+t),console.log("size="+e.size()),console.log("size E->Q = ",e.size("E","Q")),t="";for(let s,i=e.keys("E","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[E->Q]= "+t),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank P= "+e.rank("P")),console.log("contains X= "+e.contains("X")),console.log("contains Z= "+e.contains("Z")),e.delete("X"),console.log("get C="+e.get("C")),console.log("max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("height= "+e.height()),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank E= "+e.rank("E")),console.log("floor G= "+e.floor("G")),console.log("ceiling G= "+e.ceiling("G"))}}class _{static BLACK=!1;static RED=!0;constructor(t){this.compare=t,this.root=e,this._argOk=t=>f.assert(t,"Invalid argument"),this._check=()=>{let t=(e,s,i)=>!!f.nichts(e)||!(s&&this.compare(e.key,s)<=0)&&(!(i&&this.compare(e.key,i)>=0)&&(t(e.left,s,e.key)&&t(e.right,e.key,i))),e=t=>!!f.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(e(t.left)&&e(t.right)),s=t=>!!f.nichts(t)||!this._isRed(t.right)&&((t===this.root||!this._isRed(t)||!this._isRed(t.left))&&(s(t.left)&&s(t.right))),i=(t,e)=>f.nichts(t)?0==e:(this._isRed(t)||--e,i(t.left,e)&&i(t.right,e));return t(this.root,null,null)&&e(this.root)&&(()=>{for(let t=0;t<this.size();++t)if(t!=this._rankNode(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this._rankNode(t))))return!1;return!0})()&&s(this.root)&&(()=>{let t=0,e=this.root;for(;e;)this._isRed(e)||++t,e=e.left;return i(this.root,t)})()}}Node(t,e,s,i){return{key:t,val:e,color:s,size:i}}_isRed(t){return!f.nichts(t)&&t.color===_.RED}_sizeNode(t){return f.nichts(t)?0:t.size}isEmpty(){return f.nichts(this.root)}get(t){return this._argOk(t)&&this._getNode(this.root,t)}_getNode(t,e){for(;t;){let s=this.compare(e,t.key);if(s<0)t=t.left;else{if(!(s>0))return t.val;t=t.right}}}contains(t){return void 0!==this.get(t)}put(t,e){this._argOk(t)&&f.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this.root.color=_.BLACK)}_putNode(t,e,s){if(f.nichts(t))return this.Node(e,s,_.RED,1);let i=this.compare(e,t.key);return i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}deleteMin(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=_.RED),this.root=this._deleteMinNode(this.root),this.isEmpty()||(this.root.color=_.BLACK)}_deleteMinNode(t){return f.nichts(t.left)?null:(this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteMinNode(t.left),this._balance(t))}deleteMax(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=_.RED),this.root=this._deleteMaxNode(this.root),this.isEmpty()||(this.root.color=_.BLACK)}_deleteMaxNode(t){return this._isRed(t.left)&&(t=this._rotateRight(t)),f.nichts(t.right)?null:(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),t.right=this._deleteMaxNode(t.right),this._balance(t))}delete(t){this._argOk(t)&&!this.contains(t)||(this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=_.RED),this.root=this._deleteNode(this.root,t),this.isEmpty()||(this.root.color=_.BLACK))}_deleteNode(t,e){if(this.compare(e,t.key)<0)this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteNode(t.left,e);else{if(this._isRed(t.left)&&(t=this._rotateRight(t)),0==this.compare(e,t.key)&&f.nichts(t.right))return null;if(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),0==this.compare(e,t.key)){let e=this._minNode(t.right);t.key=e.key,t.val=e.val,t.right=this._deleteMinNode(t.right)}else t.right=this._deleteNode(t.right,e)}return this._balance(t)}_rotateRight(t){if(f.nichts(t)||!this._isRed(t.left))throw Error("bad input to rotateRight");let e=t.left;return t.left=e.right,e.right=t,e.color=e.right.color,e.right.color=_.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_rotateLeft(t){if(f.nichts(t)||!this._isRed(t.right))throw Error("bad input to rotateLeft");let e=t.right;return t.right=e.left,e.left=t,e.color=e.left.color,e.left.color=_.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_flipColors(t){t.color=!t.color,t.left.color=!t.left.color,t.right.color=!t.right.color}_moveRedLeft(t){return this._flipColors(t),this._isRed(t.right.left)&&(t.right=this._rotateRight(t.right),t=this._rotateLeft(t),this._flipColors(t)),t}_moveRedRight(t){return this._flipColors(t),this._isRed(t.left.left)&&(t=this._rotateRight(t),this._flipColors(t)),t}_balance(t){return this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}height(){return this._height(this.root)}_height(t){return f.nichts(t)?-1:1+Math.max(this._height(t.left),this._height(t.right))}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return f.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return f.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,s);let r=this._floorNode(t.right,s);return r||t}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(f.nichts(e))throw Error("argument to ceiling is too small");return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,s);let r=this._ceilingNode(t.left,s);return r||t}select(t){if(t<0||t>=this.size())throw Error(`argument to select is invalid: ${t}`);return this._selectNode(this.root,t)}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new l;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}return e}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}static load(t,e){let s=new _(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t,e=_.load("SEARCHEXAMPLE".split(""),a);t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log(t),e.isEmpty(),console.log("height= "+e.height()+", size= "+e.size()),console.log("get X= "+e.get("X")),console.log("contains X= "+e.contains("X")),console.log("min= "+e.min()+",max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("min= "+e.min()+",max= "+e.max()),e.delete("R"),console.log("contains R= "+e.contains("R")),console.log("floor J= "+e.floor("J")),console.log("ceiling J= "+e.ceiling("J")),console.log("rank M= "+e.rank("M")),t="";for(let s,i=e.keys("D","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[D-Q]= "+t),console.log("size[E-P]= "+e.size("E","P"))}}class w{static indexOf(t,e){let s=0,r=t.length-1;for(;s<=r;){let n=s+i.ndiv(r-s,2);if(e<t[n])r=n-1;else{if(!(e>t[n]))return n;s=n+1}}return-1}static test(){let t="84 48 68 10 18 98 12 23 54 57 33 16 77 11 29".split(" ").map((t=>+t)).sort();"23 50 10 99 18 23 98 84 11 10 48 77 13 54 98 77 77 68".split(" ").map((t=>+t)).forEach((e=>{w.indexOf(t,e)<0&&console.log(e)}))}}class N{Node(t,e,s,i){return{key:t,val:e,height:s,size:i}}constructor(t){this.compare=t,this.root=e}isEmpty(){return f.nichts(this.root)}_sizeNode(t){return f.nichts(t)?0:t.size}height(){return this._heightNode(this.root)}_heightNode(t){return f.nichts(t)?-1:t.height}get(t){if(f.nichts(t))throw Error("argument to get() is null");let e=this._getNode(this.root,t);if(e)return e.val}_getNode(t,s){if(!t)return e;let i=this.compare(s,t.key);return i<0?this._getNode(t.left,s):i>0?this._getNode(t.right,s):t}contains(t){return void 0!==this.get(t)}put(t,e){if(f.nichts(t))throw Error("first argument to put() is null");void 0===e?this.delete(t):this.root=this._putNode(this.root,t,e)}_putNode(t,e,s){if(!t)return this.Node(e,s,0,1);let i=this.compare(e,t.key);if(i<0)t.left=this._putNode(t.left,e,s);else{if(!(i>0))return t.val=s,t;t.right=this._putNode(t.right,e,s)}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balanceNode(t)}_balanceNode(t){return this._balanceFactor(t)<-1?(this._balanceFactor(t.right)>0&&(t.right=this._rotateRight(t.right)),t=this._rotateLeft(t)):this._balanceFactor(t)>1&&(this._balanceFactor(t.left)<0&&(t.left=this._rotateLeft(t.left)),t=this._rotateRight(t)),t}_balanceFactor(t){return this._heightNode(t.left)-this._heightNode(t.right)}_rotateRight(t){let e=t.left;return t.left=e.right,e.right=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}_rotateLeft(t){let e=t.right;return t.right=e.left,e.left=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}delete(t){if(f.nichts(t))throw Error("argument to delete() is null");this.contains(t)&&(this.root=this._deleteNode(this.root,t))}_deleteNode(t,e){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(!t.left)return t.right;if(!t.right)return t.left;let e=t;(t=this.min(e.right)).right=this.deleteMin(e.right),t.left=e.left}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)}deleteMin(){if(this.isEmpty())throw Error("called deleteMin() with empty symbol table");this.root=this._deleteMinNode(this.root)}_deleteMinNode(t){return t.left?(t.left=this._deleteMinNode(t.left),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.right}deleteMax(){if(this.isEmpty())throw Error("called deleteMax() with empty symbol table");this.root=this._deleteMaxNode(this.root)}_deleteMaxNode(t){return t.right?(t.right=this._deleteMaxNode(t.right),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.left}min(){if(this.isEmpty())throw Error("called min() with empty symbol table");return this._minNode(this.root).key}_minNode(t){return t.left?this._minNode(t.left):t}max(){if(this.isEmpty())throw Error("called max() with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return t.right?this._maxNode(t.right):t}floor(t){if(f.nichts(t))throw Error("argument to floor() is null");if(this.isEmpty())throw Error("called floor() with empty symbol table");let e=this._floorNode(this.root,t);if(e)return e.key}_floorNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,s);let r=this._floorNode(t.right,s);return r||t}ceiling(t){if(f.nichts(t))throw Error("argument to ceiling() is null");if(this.isEmpty())throw Error("called ceiling() with empty symbol table");let e=this._ceilingNode(this.root,t);if(e)return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,s);let r=this._ceilingNode(t.left,s);return r||t}select(t){if(t<0||t>=this.size())throw Error("k is not in range 0-"+(this.size()-1));let e=this._selectNode(this.root,t);if(e)return e.key}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t}rank(t){if(f.nichts(t))throw Error("argument to rank() is null");return this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keysInOrder(){let t=new l;return this._keysInOrderNode(this.root,t),t.iter()}_keysInOrderNode(t,e){f.nichts(t)||(this._keysInOrderNode(t.left,e),e.enqueue(t.key),this._keysInOrderNode(t.right,e))}keysLevelOrder(){let t=new l;if(!this.isEmpty()){let e=new l;for(e.enqueue(this.root);!e.isEmpty();){let s=e.dequeue();t.enqueue(s.key),s.left||e.enqueue(s.left),s.right&&e.enqueue(s.right)}}return t}keys(t,e){if(0==arguments.length)return this.keysInOrder();if(f.nichts(t))throw Error("first argument to keys() is null");if(f.nichts(e))throw Error("second argument to keys() is null");let s=new l;return this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}}size(t,e){if(0==arguments.length)return this._sizeNode(this.root);if(f.nichts(t))throw Error("first argument to size() is null");if(f.nichts(e))throw Error("second argument to size() is null");return this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}_check(){let t=this;return function e(s,i,r){return!s||!(!i&&t.compare(s.key,i)<=0)&&(!(!r&&t.compare(s.key,r)>=0)&&(e(s.left,i,s.key)&&e(s.right,s.key,r)))}(this.root,null,null)&&function e(s){if(!s)return!0;let i=t._balanceFactor(s);return!(i>1||i<-1)&&(e(s.left)&&e(s.right))}(this.root)&&function e(s){return!s||s.size==t._sizeNode(s.left)+t._sizeNode(s.right)+1&&(e(s.left)&&e(s.right))}(this.root)&&function(){for(let e=0;e<t.size();e++)if(e!=t.rank(t.select(e)))return!1;for(let e,s=t.keys().iterator();s.hasNext();)if(e=s.next(),0!=this.compare(e,t.select(t.rank(key))))return!1;return!0}()}static test(){let t=new N(a);"SEARCHEXAMPLE".split("").forEach(((e,s)=>t.put(e,s)));for(let e,s=t.keys();s.hasNext();)e=s.next(),console.log(e+" "+t.get(e))}}const k=Math.sqrt(2);function v(t,e){return{parent:e,pos:t,f:0,g:0,h:0,pid:`${t[0]},${t[1]}`,equals(t){return this.pos[0]==t.pos[0]&&this.pos[1]==t.pos[1]}}}class x{static manhattan(t,e,s=1){return s*Math.abs(t[1]-e[1])+s*Math.abs(t[0]-e[0])}static euclidean(t,e,s=1){let i=e[0]-t[0],r=e[1]-t[1];return s*(i*i+r*r)}static diagonal(t,e,s=1,i=k){let r=Math.abs(e[0]-t[0]),n=Math.abs(e[1]-t[1]);return s*(r+n)+(i-2*s)*Math.min(r,n)}constructor(t){this.grid=t}pathTo(t,e,s){return this._search(this.grid,t,e,s)}_search(t,e,s,i){const r=i.compare,n=t.length,o=t[0].length,h=new Map,l=new Map,a=new u(r,10),c=v(s),d=v(e),f=[[1,0],[-1,0],[0,1],[0,-1]],g=(t,e)=>{for(;t;t=t.parent)e.unshift(t.pos);return e};i.wantDiagonal&&f.push([1,1],[1,-1],[-1,1],[-1,-1]),l.set(d.pid,d.g),a.insert(d);let p,m=[];for(;!a.isEmpty();){if(p=a.delMin(),l.delete(p.pid),h.set(p.pid,0),p.equals(c))return g(p,[]);m.length=0;for(let t,e=0;e<f.length;++e)t=[p.pos[0]+f[e][0],p.pos[1]+f[e][1]],t[0]>o-1||t[0]<0||t[1]>n-1||t[1]<0||i.blocked(t)||m.push(v(t,p));m.forEach((t=>{h.has(t.pid)||(t.g=p.g+i.cost(),t.h=i.calcHeuristic(t.pos,c.pos),t.f=t.g+t.h,l.has(t.pid)&&t.g>l.get(t.pid)||(a.insert(t),l.set(t.pid,t.g)))}))}}static test(){let t,e,s,i=[[0,1,0,0,0,0],[0,0,0,0,0,0],[0,1,0,1,0,0],[0,1,0,0,1,0],[0,0,0,0,1,0]],r=i.length,n=i[0].length,o={wantDiagonal:!1,compare:(t,e)=>t.f-e.f,cost:()=>1,blocked:t=>0!=i[t[1]][t[0]],calcHeuristic:(t,e)=>x.euclidean(t,e)},h=new x(i).pathTo([0,0],[5,4],o);h?(s="",h.forEach((t=>{s+=`[${t[0]},${t[1]}] `})),console.log(s),e=f.fill(r,(()=>f.fill(n,"#"))),t=0,h.forEach((s=>{e[s[1]][s[0]]=""+t,++t})),e.forEach((t=>{console.log(t.toString())}))):console.log("no path")}}return{AStarGrid:x,AVLTreeST:N,RedBlackBST:_,BST:y,BinarySearch:w,BinarySearchST:m,FrequencyCounter:g,SequentialSearchST:p}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core"),require("../main/math"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/search"]=s}(this),function(t,e){"use strict";function s(s,i,r,n){r||(r=t["io/czlab/mcfud/algo/basic"]()),n||(n=t["io/czlab/mcfud/algo/sort"]()),s||(s=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/math"]());const{prnIter:o,TreeMap:h,Bag:l,Stack:a,Queue:c,ST:u,StdCompare:d}=r,{IndexMinPQ:f,MinPQ:g}=n,{is:p,u:m}=(Math.floor,s);function y(t,e){if(t<0||t>=e)throw Error(`vertex ${t} is not between 0 and ${e-1}`);return!0}class _{constructor(t){m.assert(t>=0,"Number of vertices must be non-negative"),this.verts=t,this.edges=0,this.adjls=m.fill(t,(()=>new l))}clone(){let t=new _(this.V());t.edges=this.E(),t.adjls=[];for(let e=0,s=this.V();e<s;++e)t.adjls.push(this.adjls[e].clone());return t}V(){return this.verts}E(){return this.edges}addEdge(t,e){y(t,this.verts),y(e,this.verts),this.edges+=1,this.adjls[t].add(e),this.adjls[e].add(t)}adj(t){return y(t,this.verts)&&this.adjls[t]}degree(t){return y(t,this.verts)&&this.adjls[t].size()}toString(){let t=`${this.verts} vertices, ${this.edges} edges\n`;for(let e=0;e<this.verts;++e)t+=`${e}: `+o(this.adjls[e].iter()),t+="\n";return t}static load(t,e){let s=new _(t);m.assert(e.length%2==0,"wanted even n# of data points");for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}static test(){let t=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);t.degree(1),console.log(t.toString());let e=t.clone();console.log("cloned=\n"+e.toString())}}class w{constructor(t,e){this.bMarked=new Array(t.V()),this.nCount=0,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.nCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.nCount}static test(){let t,e,s=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach((i=>{e=new w(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=`${i} `);console.log(t),console.log(e.count()!=s.V()?"NOT connected":"connected")}))}}class N{constructor(t,e){this.bMarked=new Array(t.V()),y(e,this.bMarked.length);let s,i,r=m.fill(t.V(),(e=>t.adj(e).iter())),n=new a;for(this.bMarked[e]=!0,n.push(e);!n.isEmpty();)s=n.peek(),r[s].hasNext()?(i=r[s].next(),this.bMarked[i]||(this.bMarked[i]=!0,n.push(i))):n.pop()}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}static test(){let t,e,s=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach((i=>{e=new N(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=`${i} `);console.log(t)}))}}class k{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new a;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t=_.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new k(t,0);for(let s,i,r=0;r<t.V();++r)if(e.hasPathTo(r)){s=`0 to ${r}:  `;for(let t=e.pathTo(r);t.hasNext();)i=t.next(),s+=0==i?i:`-${i}`;console.log(s)}else console.log(`0 to ${r}:  not connected\n`)}}function v(t,e,s){let i,r=[];for(i=0;i<t.V();++i)s.mDistTo[i]=1/0;for(e.forEach((t=>{s.bMarked[t]=!0,s.mDistTo[t]=0,r.push(t)}));r.length>0;){i=r.shift();for(let e,n=t.adj(i).iter();n.hasNext();)e=n.next(),s.bMarked[e]||(s.edgeTo[e]=i,s.mDistTo[e]=s.mDistTo[i]+1,s.bMarked[e]=!0,r.push(e))}}function x(t,e){if(!t||0==t.length)throw Error("argument is null or empty");return t.forEach((t=>y(t,e))),!0}class E{constructor(t,e){this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V()),p.vec(e)||(e=[e]),x(e,t.V()),v(t,e,this),function(t,e,s){if(0!=s.mDistTo[e])throw Error(`dist of source ${e} to itself = ${s.mDistTo[e]}`);for(let e=0;e<t.V();++e)for(let i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s.hasPathTo(e)!==s.hasPathTo(i))throw Error(`edge ${e}-${i}hasPathTo(${e})=${s.hasPathTo(e)}hasPathTo(${i})=${s.hasPathTo(i)}`);if(s.hasPathTo(e)&&s.mDistTo[i]>s.mDistTo[e]+1)throw Error(`edge ${e}-${i}distTo[${e}]=${s.mDistTo[e]}distTo[${i}]=${s.mDistTo[i]}`)}for(let i,r=0;r<t.V();++r)if(s.hasPathTo(r)&&r!=e&&(i=s.edgeTo[r],s.mDistTo[r]!=s.mDistTo[i]+1))throw Error(`shortest path edge ${i}-${r} distTo[${i}]= ${s.mDistTo[i]}distTo[${r}]= ${s.mDistTo[r]}`)}(t,e,this)}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return y(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new a;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t=_.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new E(t,0);for(let s,i=0;i<t.V();++i)if(e.hasPathTo(i)){s=`0 to ${i}(${e.distTo(i)}): `;for(let t,r=e.pathTo(i);r.hasNext();)t=r.next(),s+=0==t?`${t}`:`-${t}`;console.log(s)}else console.log(`0 to ${i} (-):  not connected\n`)}}class b{constructor(t,e,s){if(t<0)throw Error("vertex index must be a non-negative integer");if(e<0)throw Error("vertex index must be a non-negative integer");this.v=t,this.w=e,this._weight=s}weight(){return this._weight}either(){return this.v}other(t){if(t==this.v)return this.w;if(t==this.w)return this.v;throw Error("Illegal endpoint")}static comparator(t,e){return t._weight<e._weight?-1:t._weight>e._weight?1:0}toString(){return`${this.v}-${this.w} ${this._weight}`}static test(){console.log(new b(12,34,5.67).toString())}}class T{constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this._V=t,this._E=0,this.adjls=m.fill(t,(()=>new l))}static randGraph(t,e){let s=new T(t);if(e<0)throw Error("Number of edges must be non-negative");for(let i,r,n,o=0;o<e;++o)r=m.randInt(t),n=m.randInt(t),i=Math.round(100*m.rand())/100,s.addEdge(new b(r,n,i));return s}clone(){let t=new T(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){let e=t.either(),s=t.other(e);y(e,this._V),y(s,this._V),this.adjls[e].add(t),this.adjls[s].add(t),this._E+=1}adj(t){return y(t,this._V)&&this.adjls[t]}degree(t){return y(t,this._V)&&this.adjls[t].size()}edges(){const t=new l;for(let e,s,i,r=0;r<this._V;++r)for(s=0,e=this.adjls[r].iter();e.hasNext();)i=e.next(),i.other(r)>r?t.add(i):i.other(r)==r&&(s%2==0&&t.add(i),++s);return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e,s=0;s<this._V;++s){for(t+=`${s}: `,e=this.adjls[s].iter();e.hasNext();)t+=`${e.next()}, `;t+="\n"}return t}static load(t,e){let s=new T(t);m.assert(e.length%3==0,"Invalid data size");for(let i=0;i<e.length;i+=3)y(e[i],t)&&y(e[i+1],t)&&s.addEdge(new b(e[i],e[i+1],e[i+2]));return s}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38 2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34 6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(" ").map((t=>+t)),e=T.load(8,t);console.log(e.toString())}}class M{constructor(t){this.bMarked=new Array(t.V()),this._id=new Array(t.V()),this._size=new Array(t.V()),this.nCount=0;for(let e=0;e<t.V();++e)this.bMarked[e]||(this._dfs(t,e),++this.nCount)}_dfs(t,e){this.bMarked[e]=!0,this._id[e]=this.nCount,this._size[this.nCount]+=1;for(let s,i,r=t.adj(e).iter();r.hasNext();)s=r.next(),t instanceof T?(i=s.other(e),this.bMarked[i]||this._dfs(t,i)):this.bMarked[s]||this._dfs(t,s)}id(t){return y(t,this.bMarked.length)&&this._id[t]}size(t){return y(t,this.bMarked.length)&&this._size[this._id[t]]}count(){return this.nCount}connected(t,e){return y(t,this.bMarked.length)&&y(e,this.bMarked.length)&&this.id(t)==this.id(e)}static test(){let t=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]),e=new M(t),s=e.count();console.log(s+" components");let i=m.fill(s,(()=>[]));for(let s=0;s<t.V();++s)i[e.id(s)].push(s);for(let t,e=0;e<s;++e)t="",i[e].forEach((e=>t+=e.toString()+" ")),console.log(t)}}class I{static load(t,e){if(t<0)throw Error("verts in a Digraph must be non-negative");m.assert(e.length%2==0,"expected even n# of data-length");let s=new I(t);for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}constructor(t){if(t<0)throw Error("verts in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=m.fill(t,0),this.adjls=m.fill(t,(()=>new l))}clone(){let t=this,e=new I(this.V());e._E=this.E(),e._indegree=m.fill(e.V(),(e=>t._indegree[e]));for(let t=0;t<e.V();++t)e.adjls[t]=this.adjls[t].clone();return e}V(){return this._V}E(){return this._E}addEdge(t,e){y(t,this._V)&&y(e,this._V),this.adjls[t].add(e),this._indegree[e]+=1,++this._E}adj(t){return y(t,this._V)&&this.adjls[t]}outdegree(t){return y(t,this._V)&&this.adjls[t].size()}indegree(t){return y(t,this._V)&&this._indegree[t]}reverse(){let t=new I(this._V);for(let e,s=0;s<this._V;++s)for(e=this.adjls[s].iter();e.hasNext();)t.addEdge(e.next(),s);return t}toString(){let t=`${this._V} vertices, ${this._E} edges\n`;for(let e,s=0;s<this._V;++s){for(t+=`${s}: `,e=this.adjls[s].iter();e.hasNext();)t+=`${e.next()} `;t+="\n"}return t}static test(){let t=I.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t))),e="",s="";for(let i=0;i<t.V();++i)e+=`${i}=${t.indegree(i)}, `,s+=`${i}=${t.outdegree(i)},`;console.log("indegreee= "+e),console.log("outdegreee= "+s),console.log(t.toString());let i=t.clone();console.log("cloned=\n"+i.toString());let r=t.reverse();console.log("rev'ed=\n"+r.toString())}}class S{constructor(t,e){this.bMarked=new Array(t.V()),p.vec(e)||(e=[e]),x(e,t.V()),e.forEach((e=>{this.bMarked[e]||this._dfs(t,e)}))}_dfs(t,e){this.mCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.mCount}static test(){let t=I.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t))),e="",s=new S(t,[1,2,6]);for(let i=0;i<t.V();++i)s.marked(i)&&(e+=`${i} `);s.count(),console.log(e)}}class O{constructor(t){this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V()),this.mCycle=e;for(let e=0;e<t.V();++e)this.bMarked[e]||this.mCycle||this._dfs(t,e)}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();){if(s=i.next(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new a;for(let t=e;t!=s;t=this.edgeTo[t])this.mCycle.push(t);this.mCycle.push(s),this.mCycle.push(e),this._check()}}else this.edgeTo[s]=e,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return!!this.mCycle}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=-1,e=-1;for(let s,i=this.cycle();i.hasNext();)s=i.next(),-1==t&&(t=s),e=s;if(t!=e)throw Error(`cycle begins with ${t} and ends with ${e}\n`)}return!0}static test(){let t="2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map((t=>+t)),e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9\n               10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8\n               6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t));[new O(I.load(13,e)),new O(I.load(13,t))].forEach((t=>{t.hasCycle()?(console.log("Directed cycle: "),console.log(o(t.cycle()))):console.log("No directed cycle")}))}}class q{constructor(t,e,s){if(t<0)throw Error("Vertex names must be non-negative integers");if(e<0)throw Error("Vertex names must be non-negative integers");this.v=t,this.w=e,this._weight=s}from(){return this.v}to(){return this.w}weight(){return this._weight}toString(){return`${this.v}->${this.w} ${Number(this._weight).toFixed(2)}`}static test(){console.log(new q(12,34,5.67).toString())}}class z{constructor(t){if(t<0)throw Error("Number of vertices in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=new Array(t),this.adjls=m.fill(t,(()=>new l))}static randGraph(t,e){if(e<0)throw Error("n# edges in a Digraph must be non-negative");let s=new z(t);for(let i=0;i<e;++i)s.addEdge(new q(m.randInt(t),m.randInt(t),.01*_randInt(100)));return s}static load(t,e){if(t<0)throw Error("n# vertices in a Digraph must be non-negative");m.assert(e.length%3==0,"bad data length");let s=new z(t);for(let i=0;i<e.length;i+=3)y(e[i],t)&&y(e[i+1],t)&&s.addEdge(new q(e[i],e[i+1],e[i+2]));return s}clone(){let t=new z(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t._indegree[e]=this._indegree(e);for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){m.assert(t instanceof q,"Expected DirectedEdge");let e=t.to(),s=t.from();y(s,this._V),y(e,this._V),this.adjls[s].add(t),this._indegree[e]+=1,this._E++}adj(t){return y(t,this._V)&&this.adjls[t]}outdegree(t){return y(t,this._V)&&this.adjls[t].size()}indegree(t){return y(t,this._V)&&this._indegree[t]}edges(){const t=new l;for(let e=0;e<this._V;++e)for(let s=this.adj(e).iter();s.hasNext();)t.add(s.next());return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e=0;e<this._V;++e)t+=`${e}: `+o(this.adjls[e].iter())+"\n";return t}static test(){let t="4 5 0.35\n        5 4 0.35\n        4 7 0.37\n        5 7 0.28\n        7 5 0.28\n        5 1 0.32\n        0 4 0.38\n        0 2 0.26\n        7 3 0.39\n        1 3 0.29\n        2 7 0.34\n        6 2 0.40\n        3 6 0.52\n        6 0 0.58\n        6 4 0.93".split(/\s+/).map((t=>+t)),e=z.load(8,t);console.log(e.toString())}}class A{constructor(t){this._pre=new Array(t.V()),this._post=new Array(t.V()),this.preCounter=0,this.postCounter=0,this.postorder=new c,this.preorder=new c,this.bMarked=new Array(t.V());for(let e=0;e<t.V();e++)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.bMarked[e]=!0,this._pre[e]=this.preCounter++,this.preorder.enqueue(e);for(let s,i=t.adj(e).iter();i.hasNext();)s=t instanceof z?i.next().to():i.next(),this.bMarked[s]||this._dfs(t,s);this.postorder.enqueue(e),this._post[e]=this.postCounter++}pre(t){return y(t,this.bMarked.length)&&this._pre[t]}post(t){return y(t,this.bMarked.length)&&this._post[t]}postOrder(){return this.postorder.iter()}preOrder(){return this.preorder.iter()}reversePost(){let t=new a;for(let e=this.postorder.iter();e.hasNext();)t.push(e.next());return t.iter()}_check(){let t,e=0;for(t=this.postOrder();t.hasNext();){if(this.post(t.next())!=e)throw Error("post(v) and post() inconsistent");++e}for(e=0,t=this.preOrder();t.hasNext();){if(this.pre(t.next())!=e)throw Error("pre(v) and pre() inconsistent");++e}return!0}static test(){let t=I.load(13,"2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map((t=>+t)));console.log(t.toString());let e=new A(t);console.log("   v  pre  post"),console.log("--------------");for(let s=0;s<t.V();++s)console.log(`    ${s}  ${e.pre(s)}  ${e.post(s)}\n`);console.log("Preorder:  "),console.log(o(e.preOrder())),console.log("Postorder:  "),console.log(o(e.postOrder())),console.log(""),console.log("Reverse postorder: "),console.log(o(e.reversePost()))}}class R{constructor(t){m.assert(t instanceof z,"Expected EdgeWeightedDigraph"),this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s=i.to(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new a;let t=i;for(;t.from()!=s;)this.mCycle.push(t),t=this.edgeTo[t.from()];return void this.mCycle.push(t)}}else this.edgeTo[s]=i,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return m.echt(this.mCycle)}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=e,s=e;for(let e,i=this.cycle();i.hasNext();){if(e=i.next(),t||(t=e),s&&s.to()!=e.from())throw Error(`cycle edges ${s} and ${e} not incident\n`);s=e}if(s.to()!=t.from())throw Error(`cycle edges ${s} and ${t} not incident\n`)}return!0}static test(){let t=13,e=new z(t);m.shuffle(m.fill(t,(t=>t)));for(let s,i,r,n=0;n<8;++n){do{i=m.randInt(t),r=m.randInt(t)}while(i>=r);s=m.rand(),e.addEdge(new q(i,r,s))}for(let s=0;s<6;++s)e.addEdge(new q(m.randInt(t),m.randInt(t),m.rand()));console.log(e.toString());let s=new R(e);s.hasCycle()?console.log("Cycle: "+o(s.cycle())):console.log("No directed cycle")}}class D{constructor(t){this.st=new u,t.forEach((t=>t.forEach(((t,e)=>{this.st.contains(t)||this.st.put(t,this.st.size())})))),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this._graph=new _(this.st.size()),t.forEach((t=>{let e=this.st.get(t[0]);for(let s,i=1;i<t.length;++i)s=this.st.get(t[i]),this._graph.addEdge(e,s)}))}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return y(t,this._graph.V())&&this.keys[t]}graph(){return this._graph}static test(){let t="JFK MCO\n                  ORD DEN\n                  ORD HOU\n                  DFW PHX\n                  JFK ATL\n                  ORD DFW\n                  ORD PHX\n                  ATL HOU\n                  DEN PHX\n                  PHX LAX\n                  JFK ORD\n                  DEN LAS\n                  DFW HOU\n                  ORD ATL\n                  LAS LAX\n                  ATL MCO\n                  HOU MCO\n                  LAS PHX".split(/\s+/),e=new D(m.partition(2,t)),s=e.graph();["JFK","LAX"].forEach((t=>{if(e.contains(t)){let i=e.indexOf(t);console.log(t);for(let t=s.adj(i).iter();t.hasNext();)console.log("   "+e.nameOf(t.next()))}else console.log("input not contain '"+t+"'")}))}}class L{constructor(t){this.st=new u,t.forEach((t=>t.forEach((t=>{this.st.contains(t)||this.st.put(t,this.st.size())})))),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this.graph=new I(this.st.size()),t.forEach((t=>{let e=this.st.get(t[0]);for(let s=1;s<t.length;++s)this.graph.addEdge(e,this.st.get(t[s]))}))}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return y(t,this.graph.V())&&this.keys[t]}digraph(){return this.graph}static test(){let t="JFK MCO\n              ORD DEN\n              ORD HOU\n              DFW PHX\n              JFK ATL\n              ORD DFW\n              ORD PHX\n              ATL HOU\n              DEN PHX\n              PHX LAX\n              JFK ORD\n              DEN LAS\n              DFW HOU\n              ORD ATL\n              LAS LAX\n              ATL MCO\n              HOU MCO\n              LAS PHX".split(/\s+/),e=new L(m.partition(2,t)),s=e.digraph();["JFK","ATL","LAX"].forEach((t=>{console.log(`${t}`);let i=s.adj(e.indexOf(t)).iter();for(;i.hasNext();)console.log("   "+e.nameOf(i.next()))}))}}class C{constructor(t){let s;if(this._order=e,this.rank=e,t instanceof z?s=new R(t):t instanceof I?(s=new O(t),s.hasCycle()||(this.rank=new Array(t.V()))):m.assert(!1,"bad arg for Topological"),s&&!s.hasCycle()){this._order=new c;for(let e,s=0,i=new A(t).reversePost();i.hasNext();)e=i.next(),this.rank&&(this.rank[e]=s++),this._order.enqueue(e)}}order(){return this._order.iter()}hasOrder(){return m.echt(this._order)}rank(t){return this.rank&&y(t,this.rank.length)&&this.hasOrder()?this.rank[t]:-1}static test(){let t=new L([["Algorithms","Theoretical CS","Databases","Scientific Computing"],["Introduction to CS","Advanced Programming","Algorithms"],["Advanced Programming","Scientific Computing"],["Scientific Computing","Computational Biology"],["Theoretical CS","Computational Biology","Artificial Intelligence"],["Linear Algebra","Theoretical CS"],["Calculus","Linear Algebra"],["Artificial Intelligence","Neural Networks","Robotics","Machine Learning"],["Machine Learning","Neural Networks"]]);for(let e=new C(t.digraph()).order();e.hasNext();)console.log(t.nameOf(e.next()))}}class P{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new a;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t)),s=I.load(13,e),i=new P(s,3);for(let e=0;e<s.V();++e)if(i.hasPathTo(e)){t=`3 to ${e}:  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?`${s}`:`-${s}`;console.log(t)}else console.log(`3 to ${e}:  not connected`)}}class V{constructor(t,e){p.vec(e)||(e=[e]),this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.mDistTo[e]=1/0;x(e,t.V())&&this._bfs(t,e)}_bfs(t,e){let s=new c;for(e.forEach((t=>{this.bMarked[t]=!0,this.mDistTo[t]=0,s.enqueue(t)}));!s.isEmpty();){let e=s.dequeue();for(let i,r=t.adj(e).iter();r.hasNext();)i=r.next(),this.bMarked[i]||(this.edgeTo[i]=e,this.mDistTo[i]=this.mDistTo[e]+1,this.bMarked[i]=!0,s.enqueue(i))}}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return y(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new a;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t)),s=I.load(13,e),i=new V(s,3);for(let e=0;e<s.V();++e)if(t="",i.hasPathTo(e)){t=`3 to ${e} (${i.distTo(e)}):  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?`${s}`:`->${s}`;console.log(t)}else console.log(`3 to ${e} (-):  not connected`)}}class ${constructor(t,e,s){m.assert(t instanceof z,"Expected EdgeWeightedDigraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw Error(`edge ${e} has negative weight`);this._distTo=new Array(t.V()),this.edgeTo=m.fill(t.V(),null),y(e,t.V());for(let e=0;e<t.V();++e)this._distTo[e]=1/0;for(this._distTo[e]=0,this.pq=new f(t.V(),s),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next())}this._check(t,e)}_relax(t){let e=t.from(),s=t.to();this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return y(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return y(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(y(t,this._distTo.length)&&this.hasPathTo(t)){let e=new a;for(let s=this.edgeTo[t];s;s=this.edgeTo[s.from()])e.push(s);return e.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&!this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.to(),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(this.edgeTo[i]){if(s=this.edgeTo[i],e=s.from(),i!=s.to())throw Error("bad edge");if(this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}else;return!0}static test(){let t="4 5 0.35\n                  5 4 0.35\n                  4 7 0.37\n                  5 7 0.28\n                  7 5 0.28\n                  5 1 0.32\n                  0 4 0.38\n                  0 2 0.26\n                  7 3 0.39\n                  1 3 0.29\n                  2 7 0.34\n                  6 2 0.40\n                  3 6 0.52\n                  6 0 0.58\n                  6 4 0.93".split(/\s+/).map((t=>+t)),e=z.load(8,t),s=new $(e,0,d);for(let t=0;t<e.V();++t)s.hasPathTo(t)?console.log(`0 to ${t} (${Number(s.distTo(t)).toFixed(2)})  ${o(s.pathTo(t))}`):console.log(`0 to ${t}         no path\n`)}}class K{constructor(t,e,s){m.assert(t instanceof T,"Expected EdgeWeightedGraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw new Error(`edge ${e} has negative weight`);for(this._distTo=m.fill(t.V(),(()=>1/0)),this._distTo[e]=0,this.compare=s,this.edgeTo=m.fill(t.V(),(()=>null)),y(e,t.V()),this.pq=new f(t.V(),this.compare),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next(),e)}this._check(t,e)}_relax(t,e){let s=t.other(e);this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return y(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return y(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(y(t,this._distTo.length)&&this.hasPathTo(t)){let e=t,s=new a;for(let i=this.edgeTo[t];i;i=this.edgeTo[e])s.push(i),e=i.other(e);return s.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&!this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.other(e),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(this.edgeTo[i]){if(s=this.edgeTo[i],i!=s.either()&&i!=s.other(s.either()))return!1;if(e=s.other(i),this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38\n                  2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34\n                  6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(/\s+/).map((t=>+t)),e=T.load(8,t),s=new K(e,6,d);for(let t,i=0;i<e.V();++i)if(s.hasPathTo(i)){t=`6 to ${i} (${Number(s.distTo(i)).toFixed(2)})  `;for(let e=s.pathTo(i);e.hasNext();)t+=`${e.next()}   `;console.log(t)}else console.log(`6 to ${i}         no path`)}}return{DepthFirstDirectedPaths:P,BreadthFirstDirectedPaths:V,SymbolGraph:D,DijkstraUndirectedSP:K,DijkstraSP:$,Topological:C,SymbolDigraph:L,EdgeWeightedDirectedCycle:R,DepthFirstOrder:A,EdgeWeightedDigraph:z,DirectedEdge:q,DirectedCycle:O,DirectedDFS:S,Digraph:I,CC:M,EdgeWeightedGraph:T,Edge:b,BreadthFirstPaths:E,DepthFirstPaths:k,NonrecursiveDFS:N,DepthFirstSearch:w,Graph:_}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core"),require("../main/math"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/graph"]=s}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());Math.floor;const{u:s,is:i}=e,r={mutationRate:.1,crossOverRate:.7,probTournament:.75,NUM_HIDDEN:1,BIAS:-1,NUM_ELITE:4,TOURNAMENT_SIZE:5,MAX_PERTURBATION:.3,ACTIVATION_RESPONSE:1,NEURONS_PER_HIDDEN:10};class n{constructor(){}gt(t){}lt(t){}eq(t){}clone(){}score(){}update(t){}}class o extends n{constructor(t,e){super(),this.value=t,this.flip=e}gt(t){return this.flip?this.value<t.value:this.value>t.value}eq(t){return this.value==t.value}lt(t){return this.flip?this.value>t.value:this.value<t.value}score(){return this.value}update(t){this.value=t}clone(){return new o(this.value,this.flip)}}class h{constructor(){this.averageScore=0,this.totalScore=0,this.bestScore=0,this.worstScore=0,this.best=undefined}}class l{constructor(t){const e=s.fill(t+1,(()=>s.randMinus1To1()));this.numInputs=e.length,this.activation=0,this.weights=e,this.error=0}}class a{constructor(t,e){this.numNeurons=t,this.neurons=s.fill(t,(()=>new l(e)))}}class c{constructor(t,e){this.fitness=e,this.genes=t,this.age=0}clone(){return new c(this.genes.slice(),this.fitness.clone())}}function u(t){let e=s.randInt(t.length),i=s.randInt(t.length);return e<i?[e,i]:[i,e]}function d(t,e){let i,r=0,n=s.rand(),o=t.map((t=>r+=t.fitness.score()/e));for(i=0;i<o.length-1;++i)if(n>=o[i]&&n<=o[i+1])return t[i];return t[0]}function f(t){let e=s.randInt(t.length),i=s.randInt(t.length);for(;e==i;)i=s.randInt2(0,t.length-1);return s.rand()<r.probTournament?t[e].fitness.gt(t[i].fitness)?t[e]:t[i]:t[e].fitness.lt(t[i].fitness)?t[e]:t[i]}function g(t,e){let s=0,i=1/0,r=new h;function n(t){s=t.fitness.score(),r.bestScore=s,r.best=t}function o(t){i=t.fitness.score(),r.worstScore=i}return e&&(i=0,s=1/0),t.forEach((t=>{e?t.fitness.score()<s?n(t):t.fitness.score()>i&&o(t):t.fitness.score()>s?n(t):t.fitness.score()<i&&o(t),r.totalScore+=t.fitness.score()})),r.averageScore=r.totalScore/t.length,r}function p(t,e="cycles"){let i=t.startTime=s.now();return t[e]=0,i}function m(t){return t.endTime=s.now()}function y(t,e,i,r,n){let o=s.randInt(e.length);for(;e.length>1&&o==t;)o=s.randInt(e.length);let h,l,a=e[t].genes,u=e[o].genes;i?[h,l]=i(a,u):(h=a.slice(),l=u.slice()),r&&(r(h),r(l));let d=n(h,e[t].fitness),f=n(l,e[o].fitness);return d.gt(f)?new c(h,d):new c(l,f)}function _(t,e){let s,i=0;for(;i<t.length&&(s=t[i],!s.fitness.eq(e.fitness)&&!e.fitness.lt(s.fitness));++i);return i}function w(t,{calcFit:e,crossOver:n,create:o,mutate:h}){if(i.num(t))return s.fill(t,(()=>o()));let l,a,u,p,m=[],y=g(t);t.sort(((t,e)=>t.fitness.lt(e.fitness)?-1:t.fitness.gt(e.fitness)?1:0));for(let e=r.NUM_ELITES,s=t.length-1;s>=0&&e>0;--s)m.push(t[s]),--e;for(;m.length<t.length;)void 0!==r.TOURNAMENT_SIZE?(u=f(t),p=f(t)):(u=d(t,y),p=d(t,y)),n?[l,a]=n(u.genes,p.genes):(l=u.genes.slice(),a=p.genes.slice()),h&&(h(l),h(a)),m.push(new c(l,e(l,u.fitness)),new c(a,e(a,p.fitness)));for(;m.length>t.length;)m.pop();return m}return{NeuronLayer:a,Neuron:l,NeuralNet:class{constructor(t,e,i,r){this.layers=function(n){if(i>0){n.push(new a(r,t));for(let t=0;t<i-1;++t)n.push(new a(r,r))}return s.conj(n,new a(e,i>0?r:t))}([]),this.numOfWeights=this.layers.reduce(((t,e)=>t+e.neurons.reduce(((t,e)=>t+e.weights.length),0)),0),this.numOutputs=e,this.numInputs=t,this.numHidden=i,this.neuronsPerHidden=r}putWeights(t){s.assert(t.length>=this.numOfWeights,"bad input to putWeights");let e=0;this.layers.forEach((s=>s.neurons.forEach((s=>s.weights.forEach(((i,r)=>s.weights[r]=t[e++]))))))}getWeights(){const t=[];for(let e=0;e<this.numHidden+1;++e)for(let s=0;s<this.layers[e].numNeurons;++s)for(let i=0;i<this.layers[e].neurons[s].numInputs;++i)t.push(this.layers[e].neurons[s].weights[i]);return t}getNumberOfWeights(){return this.numOfWeights}feedForward(t){return this.update(t)}update(t){s.assert(t.length>=this.numInputs,"invalid input size");let e,i,n,o=[];return this.layers.forEach(((s,h)=>{h>0&&(t=o),o=[],s.neurons.forEach((s=>{n=0,e=0,i=s.numInputs;for(let r=0;r<i-1;++r)e+=s.weights[r]*t[n++];e+=s.weights[i-1]*r.BIAS,o.push(s.activation=this.sigmoid(e,r.ACTIVATION_RESPONSE))}))})),s.assert(o.length==this.numOutputs,"out length incorrect")?o:[]}sigmoid(t,e){return 1/(1+Math.exp(-t/e))}calcSplitPoints(){let t=[],e=0;return this.layers.forEach((s=>s.neurons.forEach((s=>{e+=s.numInputs,t.push(e-1)})))),t}},runGASearch:function(t,e){let i,r,n=p(e),o=e.maxCycles||100,h=1e3*(e.maxSeconds||30),l=function*([t,e],{mutate:i,create:r,maxAge:n,calcFit:o,poolSize:h,crossOver:l}){let a,c=r();yield c;let u,d,f,g,p,m=[c],w=[c];h=h||1,n=n||50;for(let t=0;t<h-1;++t)a=r(),a.fitness.gt(c.fitness)&&(yield c=a,w.push(a)),m.push(a);for(p=h-1,g=1;;)if(s.now()-t>e&&(yield c),g=g>0?g-1:p,a=m[g],d=y(g,m,l,i,o),a.fitness.gt(d.fitness)){if(void 0===n)continue;if(a.age+=1,n>a.age)continue;if(f=_(w,d,w.length),u=f/w.length,s.rand()<Math.exp(-u)){m[g]=d;continue}c.age=0,m[g]=c}else d.fitness.gt(a.fitness)?(d.age=0,m[g]=d,d.fitness.gt(c.fitness)&&(yield c=d,w.push(c))):(d.age=a.age+1,m[g]=d)}([n,h],e);for(;;){if(i=l.next().value,r=m(e),r-n>h){r=null;break}if(!t.gt(i.fitness))break;if(e.cycles>=o)break;e.cycles+=1}return[null==r,i]},runGACycle:function(t,e){let i,r,{maxCycles:n,targetScore:o,maxSeconds:h}=e,l=p(e),a=1e3*(h||30);for(n=n||100;;){if(t=w(t,e),r=m(e),r-l>a){r=null;break}if(i=g(t),s.echt(o)&&i.bestScore>=o)break;if(e.cycles>=n)break;e.cycles+=1}return e.gen++,[null==r,t]},calcStats:g,NumFitness:o,Fitness:n,Chromosome:c,mutateSM:function(t){if(s.rand()<r.mutationRate){let e,[i,r]=u(t),n=r-i-1;if(2==n)e=t[i+1],t[i+1]=t[i+2],t[i+2]=e;else if(n>2){e=s.shuffle(t.slice(i+1,r));for(let s=0,n=i+1;n<r;++n)t[n]=e[s++]}}},mutateDM:function(t){if(s.rand()<r.mutationRate){let e,i,r,[n,o]=u(t),h=t.length;o-n-1>0&&(i=t.slice(n+1,o),r=t.slice(0,n+1).concat(t.slice(o)),e=s.randInt(r.length),i=r.slice(0,e).concat(i).concat(r.slice(e)),t.length=0,i.forEach((e=>t.push(e))),s.assert(t.length==h,"mutateDM error"))}},mutateIVM:function(t){if(s.rand()<r.mutationRate){let e,[i,r]=u(t),n=t.length;if(r-i-1>1){e=t.slice(i+1,r).reverse();for(let s=0,n=i+1;n<r;++n)t[n]=e[s++]}s.assert(n==t.length,"mutateIVM error")}},mutateDIVM:function(t){if(s.rand()<r.mutationRate){let e,i,r,[n,o]=u(t),h=t.length;o-n-1>0&&(i=t.slice(n+1,o).reverse(),r=t.slice(0,n+1).concat(t.slice(o)),e=s.randInt(r.length),i=r.slice(0,e).concat(i).concat(r.slice(e)),t.length=0,i.forEach((e=>t.push(e))),s.assert(t.length==h,"mutateDIVM error"))}},crossOverOBX:function(t,e){let i,n,o,h,l;if(s.randInt2(0,t.length-2),o=t.slice(),h=e.slice(),s.rand()>r.crossOverRate||t===e);else{n=s.listIndexesOf(t,!0).slice(0,s.toGoldenRatio(t.length)[1]).sort(),i=n.map((e=>t[e])),l=0;for(let t=0;t<h.length;++t)for(let e=0;e<i.length;++e)if(h[t]==i[e]){h[t]=i[l++];break}i.length=0,l=0;for(let t=0;t<n.length;++t)i.push(e[n[t]]);for(let t=0;t<o.length;++t)for(let e=0;e<i.length;++e)if(o[t]==i[e]){o[t]=i[l++];break}}return[o,h]},crossOverPBX:function(t,e){let i,n;if(s.rand()>r.crossOverRate||t===e)i=t.slice(),n=e.slice();else{i=s.fill(t.length,null),n=s.fill(t.length,null),s.listIndexesOf(t,!0).slice(0,s.toGoldenRatio(t.length)[1]).sort().forEach((s=>{i[s]=t[s],n[s]=e[s]}));let r=0,o=0;for(let s=0;s<t.length;++s){for(;null!==n[o]&&o<t.length;)++o;for(n.indexOf(t[s])<0&&(n[o]=t[s]);null!==i[r]&&r<t.length;)++r;i.indexOf(e[s])<0&&(i[r]=e[s])}s.assert(!i.some((t=>null===t)),"crossOverPBX null error"),s.assert(!n.some((t=>null===t)),"crossOverPBX null error")}return[i,n]},crossOverRND:function(t,e){let i,n;if(s.rand()>r.crossOverRate||t===e)i=t.slice(),n=e.slice();else{let r=s.randInt(t.length);i=[],n=[];for(let s=0;s<r;++s)i.push(t[s]),n.push(e[s]);for(let s=r;s<t.length;++s)i.push(e[s]),n.push(t[s])}return[i,n]},crossOverPMX:function(t,e){let i=t.slice(),n=e.slice();if(s.rand()>r.crossOverRate||t===e);else{let r=s.randInt2(0,t.length-2),o=r;for(;o<=r;)o=s.randInt2(0,t.length-1);for(let h,l,a,c,u=r;u<o+1;++u)a=t[u],c=e[u],a!=c&&(h=i.indexOf(a),l=i.indexOf(c),s.swap(i,h,l),h=n.indexOf(a),l=n.indexOf(c),s.swap(n,h,l))}return[i,n]},crossOverAtSplits:function(t,e,i){let n,o;if(s.rand()>r.crossOverRate||t===e)n=t.slice(),o=e.slice();else{let r=i[s.randInt2(0,i.length-2)],h=i[s.randInt2(r,i.length-1)];n=[],o=[];for(let s=0;s<t.length;++s)s<r||s>=h?(n.push(t[s]),o.push(e[s])):(n.push(e[s]),o.push(t[s]))}return[n,o]},hillClimb:function(t,e,i,r,n,o){o.startTime=s.now();let h,l=t(n);for(;!i(l);)h=t(r(l)),e(l,h)&&(l=h);return o.endTime=s.now(),l},showBest(t,e,i){console.log(s.fill(80,"-").join("")),console.log("total time: "+s.prettyMillis(e.endTime-e.startTime)),i&&console.log("time expired"),console.log("total generations= "+e.gen),console.log("total cycles= "+e.cycles),console.log("fitness= "+t.fitness.score()),console.log(s.fill(80,"-").join(""))},config:t=>s.inject(r,t)}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core")):t["io/czlab/mcfud/algo/NNetGA"]=s}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());const s=Math.floor,{u:i,is:r}=e,n={INPUT:0,HIDDEN:1,OUTPUT:2,BIAS:3,NONE:4},o={NEURON:0,LINK:1},h={SNAPSHOT:0,ACTIVE:1},l={numInputs:0,numOutputs:0,bias:-1,sigmoidResponse:1,numAddLinkAttempts:5,numTrysToFindLoopedLink:5,numTrysToFindOldLink:5,chanceAddLink:.07,chanceAddNode:.03,chanceAddRecurrentLink:-1,mutationRate:.8,maxWeightPerturbation:.5,probabilityWeightReplaced:.1,activationMutationRate:.1,maxActivationPerturbation:.1,compatibilityThreshold:.26,youngFitnessBonus:1.3,youngBonusAgeThreshhold:10,survivalRate:0,oldAgeThreshold:50,oldAgePenalty:.7,crossOverRate:.7,numGensAllowedNoImprovement:15,maxPermittedNeurons:100,numBestElites:4};function a(t,e=!1){return{value:t,gt(t){return e?this.value<t.value:this.value>t.value},eq(t){return this.value==t.value},lt(t){return e?this.value>t.value:this.value<t.value},score(){return this.value},update(t){this.value=t},clone(){return a(this.value,e)}}}class c{constructor(t,e=null,s=!1){this.pos=e?e.slice():[0,0],this.activation=1,this.recurrent=s,r.vec(t)?(this.id=t[0],this.neuronType=t[1]):(this.id=0,this.neuronType=t)}clone(){let t=new c(this.neuronType);return t.id=this.id,t.activation=this.activation,t.recurrent=this.recurrent,t.pos=this.pos.slice(),t}static from(t,e,s=null,i=!1){return new c([t,e],s,i)}}class u{constructor(t,e,s,r=!0,n=null,o=!1){this.fromNeuron=t,this.toNeuron=e,this.innovationID=s,this.recurrent=!0===o,this.enabled=!1!==r,this.weight=null===n?i.randMinus1To1():n}clone(){let t=new u;return t.fromNeuron=this.fromNeuron,t.toNeuron=this.toNeuron,t.innovationID=this.innovationID,t.recurrent=this.recurrent,t.enabled=this.enabled,t.weight=this.weight,t}}class d{constructor(t,e,s,i,r=n.NONE,o=null){this.pos=o?o.slice():[0,0],this.innovationID=i,this.innovationType=s,this.neuronID=0,this.neuronType=r,this.neuronIn=t,this.neuronOut=e}static from(t,e){let s=new d(-1,-1,null,e,t.neuronType,t.pos);return s.neuronID=t.id,s}}class f{constructor(t,e){this.NEURON_COUNTER=t.length-1,this.INNOV_COUNTER=0,this.vecInnovs=t.map((t=>d.from(t,this.nextIID()))).concat(e.map((t=>new d(t.fromNeuron,t.toNeuron,o.LINK,this.nextIID()))))}nextIID(){return this.INNOV_COUNTER++}check(t,e,s){let i=this.vecInnovs.find((i=>i.neuronIn==t&&i.neuronOut==e&&i.innovationType==s));return void 0===i?-1:i.innovationID}create(t,e,s,i=n.NONE,r=null){let h=new d(t,e,s,this.nextIID(),i,r);return o.NEURON==s&&(h.neuronID=++this.NEURON_COUNTER),this.vecInnovs.push(h),h}flush(){this.vecInnovs.length=0}getNeuronID(t){return this.vecInnovs[t].neuronID}}class g{constructor(t,e,s,i=!1){this.weight=t,this.from=e,this.out=s,this.recurrent=!0===i}clone(){let t=new g;return t.weight=this.weight,t.from=this.from,t.out=this.out,t.recurrent=this.recurrent,t}}class p{constructor(t,e,s,i){this.neuronType=t,this.neuronID=e,this.sumActivation=0,this.output=0,this.posX=0,this.posY=0,this.vecLinksIn=[],this.vecLinksOut=[],this.activation=i,this.pos=s?s.slice():[0,0]}clone(){let t=new p;return t.neuronType=this.neuronType,t.neuronID=this.neuronID,t.output=this.output,t.posX=this.posX,t.posY=this.posY,t.pos=this.pos.slice(),t.activation=this.activation,t.sumActivation=this.sumActivation,t.vecLinksIn=this.vecLinksIn.map((t=>t.clone())),t.vecLinksOut=this.vecLinksOut.map((t=>t.clone())),t}}class m{constructor(t,e){this.vecNeurons=t,this.depth=e}clone(){let t=new m(null,this.depth);return t.vecNeurons=this.vecNeurons.map((t=>t.clone())),t}compute(t,e){return this.update(t,e)}update(t,e=h.ACTIVE){let s=[],r=e==h.SNAPSHOT?this.depth:1;for(let e,h,a=0;a<r;++a){for(s.length=0,h=0;this.vecNeurons[h].neuronType==n.INPUT;)this.vecNeurons[h].output=t[h],++h;for(i.assert(this.vecNeurons[h].neuronType==n.BIAS,"expecting BIAS node"),this.vecNeurons[h].output=1,++h;h<this.vecNeurons.length;)e=this.vecNeurons[h].vecLinksIn.reduce(((t,e)=>t+e.weight*e.from.output),0),this.vecNeurons[h].output=(o=e,l=this.vecNeurons[h].activation,1/(1+Math.exp(-o/l))),this.vecNeurons[h].neuronType==n.OUTPUT&&s.push(this.vecNeurons[h].output),++h}var o,l;return e==h.SNAPSHOT&&this.vecNeurons.forEach((t=>t.output=0)),s}draw(t,e,s,i,r){}}class y{constructor(t,e,s,i=null,r=null){if(t<0)return;let o,h=0,l=1/(e+2),d=1/(s+1);if(i&&r)this.vecNeurons=i,this.vecLinks=r;else{for(this.vecNeurons=[],this.vecLinks=[],o=0;o<e;++o)this.vecNeurons.push(c.from(h++,n.INPUT,[(o+2)*l,0]));for(this.vecNeurons.push(c.from(h++,n.BIAS,[l,0])),o=0;o<s;++o)this.vecNeurons.push(c.from(h++,n.OUTPUT,[(o+1)*d,1]));for(o=0;o<e+1;++o)for(let t=0;t<s;++t)this.vecLinks.push(new u(this.vecNeurons[o].id,this.vecNeurons[e+1+t].id,e+s+1+this.vecLinks.length))}this.nextNeuronID=h,this.fitness=a(0),this.genomeID=t,this.adjustedFitness=0,this.amountToSpawn=0,this.numInputs=e,this.numOutputs=s,this.species=0}createPhenotype(t){let e=this.vecNeurons.map((t=>new p(t.neuronType,t.id,t.pos,t.activation)));return this.vecLinks.forEach((t=>{if(t.enabled){let s=e[this.getIndex(t.toNeuron)],i=e[this.getIndex(t.fromNeuron)],r=new g(t.weight,i,s,t.recurrent);i.vecLinksOut.push(r),s.vecLinksIn.push(r)}})),new m(e,t)}_randAny(){return this.vecNeurons[i.randInt2(0,this.vecNeurons.length-1)]}_randNonInputs(){return this.vecNeurons[i.randInt2(this.numInputs+1,this.vecNeurons.length-1)]}addLink(t,e,s,r,h){if(i.rand()>t)return;let l=-1,a=-1,c=!1;if(i.rand()<e)for(;r--;){let t=this._randNonInputs();if(t.neuronType!=n.BIAS&&t.neuronType!=n.INPUT&&!t.recurrent){l=a=t.id,c=t.recurrent=!0;break}}else for(;h--&&(l=this._randAny().id,a=this._randNonInputs().id,l==a||this.duplicateLink(l,a));)l=a=-1;if(l<0||a<0);else{let t=s.check(l,a,o.LINK);this.vecNeurons[this.getIndex(l)].pos[1]>this.vecNeurons[this.getIndex(a)].pos[1]&&(c=!0),t<0&&(t=s.create(l,a,o.LINK).innovationID),this.vecLinks.push(new u(l,a,t,!0,i.randMinus1To1(),c))}}addNeuron(t,e,r){if(i.rand()>t)return;let h,l,a,d,f=0,g=!1,p=this.numInputs+this.numOutputs+5;if(this.vecLinks.length<p){for(;r--;)if(f=i.randInt2(0,this.numGenes()-1-s(Math.sqrt(this.numGenes()))),h=this.vecLinks[f].fromNeuron,this.vecLinks[f].enabled&&!this.vecLinks[f].recurrent&&this.vecNeurons[this.getIndex(h)].neuronType!=n.BIAS){g=!0;break}if(!g)return}else for(;!g;)f=i.randInt2(0,this.numGenes()-1),h=this.vecLinks[f].fromNeuron,this.vecLinks[f].enabled&&!this.vecLinks[f].recurrent&&this.vecNeurons[this.getIndex(h)].neuronType!=n.BIAS&&(g=!0);this.vecLinks[f].enabled=!1;let m=this.vecLinks[f].weight,y=this.vecLinks[f].fromNeuron,_=this.vecLinks[f].toNeuron,w=(this.vecNeurons[this.getIndex(y)].pos[1]+this.vecNeurons[this.getIndex(_)].pos[1])/2,N=(this.vecNeurons[this.getIndex(y)].pos[0]+this.vecNeurons[this.getIndex(_)].pos[0])/2,k=e.check(y,_,o.NEURON);if(k>=0&&this.hasNeuron(e.getNeuronID(k))&&(k=-1),k<0){let t=e.create(y,_,o.NEURON,n.HIDDEN,[N,w]),s=c.from(this.nextNeuronID,n.HIDDEN,[N,w]);t.neuronID=s.id,d=s.id,this.nextNeuronID++,this.vecNeurons.push(s),l=e.create(y,d,o.LINK).innovationID,this.vecLinks.push(new u(y,d,l,!0,1)),a=e.create(d,_,o.LINK).innovationID,this.vecLinks.push(new u(d,_,a,!0,m))}else d=e.getNeuronID(k),l=e.check(y,d,o.LINK),a=e.check(d,_,o.LINK),(l<0||a<0)&&i.assert(!1,"Error in Genome::AddNeuron"),this.vecLinks.push(new u(y,d,l,!0,1),new u(d,_,a,!0,m)),this.vecNeurons.push(c.from(d,n.HIDDEN,[N,w]))}getIndex(t){for(let e=0;e<this.vecNeurons.length;++e)if(this.vecNeurons[e].id==t)return e;i.assert(!1,"Error in Genome::getIndex")}duplicateLink(t,e){return this.vecLinks.some((s=>s.fromNeuron==t&&s.toNeuron==e))}hasNeuron(t){return this.vecNeurons.some((e=>t==e.id))}mutateWeights(t,e,s){for(let r=0;r<this.vecLinks.length;++r)i.rand()<t&&(i.rand()<e?this.vecLinks[r].weight=i.randMinus1To1():this.vecLinks[r].weight+=i.randMinus1To1()*s)}mutateActivation(t,e){this.vecNeurons.forEach((s=>{i.rand()<t&&(s.activation+=i.randMinus1To1()*e)}))}calcCompatibility(t){let e=0,s=0,i=0,r=0,n=0,o=0;for(;e<this.vecLinks.length-1||s<t.vecLinks.length-1;){if(e==this.vecLinks.length-1){++s,++r;continue}if(s==t.vecLinks.length-1){++e,++r;continue}let h=this.vecLinks[e].innovationID,l=t.vecLinks[s].innovationID;h==l?(++e,++s,++n,o+=Math.abs(this.vecLinks[e].weight-t.vecLinks[s].weight)):(++i,h<l?++e:h>l&&++s)}const h=Math.max(this.numGenes(),t.numGenes());let l=1*r/h+1*i/h;return n>0?l+.4*o/n:l}sortGenes(){return this.vecLinks.sort(((t,e)=>t.innovationID<e.innovationID?-1:t.innovationID>e.innovationID?1:0)),this}id(){return this.genomeID}setID(t){this.genomeID=t}numGenes(){return this.vecLinks.length}numNeurons(){return this.vecNeurons.length}setFitness(t){this.fitness=a(t)}splitY(t){return this.vecNeurons[t].pos[1]}genes(){return this.vecLinks}neurons(){return this.vecNeurons}startOfGenes(){return 0}endOfGenes(){return this.vecLinks.length}clone(){let t=this,e=new y(-911);return e.fitness=t.fitness.clone(),e.genomeID=t.genomeID,e.adjustedFitness=t.adjustedFitness,e.amountToSpawn=t.amountToSpawn,e.numInputs=t.numInputs,e.numOutputs=t.numOutputs,e.species=t.species,e.vecNeurons=t.vecNeurons.map((t=>t.clone())),e.vecLinks=t.vecLinks.map((t=>t.clone())),e}}class _{constructor(t,e){this.speciesID=t,this._gensNoImprovement=0,this._age=0,this.spawnsRqd=0,this.vecMembers=[e],this._leader=e.clone(),this._bestFitness=e.fitness.score()}adjustFitnesses(){let t,e=0;this.vecMembers.forEach((s=>{t=s.fitness.score(),this._age<l.youngBonusAgeThreshhold&&(t*=l.youngFitnessBonus),this._age>l.oldAgeThreshold&&(t*=l.oldAgePenalty),e+=t,s.adjustedFitness=t/this.vecMembers.length}))}addMember(t){t.fitness.score()>this._bestFitness&&(this._bestFitness=t.fitness.score(),this._gensNoImprovement=0,this._leader=t.clone()),this.vecMembers.push(t),t.species=this.id()}purge(){return this.vecMembers.length=0,++this._gensNoImprovement,this.spawnsRqd=0,++this._age,this}calculateSpawnAmount(){this.vecMembers.forEach((t=>{this.spawnsRqd+=t.amountToSpawn}))}spawn(){let t,e;return 1==this.vecMembers.length?e=this.vecMembers[0]:(t=s(l.survivalRate*this.vecMembers.length)-1,t<0&&(t=1),e=this.vecMembers[i.randInt2(0,t)]),e.clone()}id(){return this.speciesID}bestFitness(){return this._bestFitness}age(){return this._age}leader(){return this._leader}numToSpawn(){return this.spawnsRqd}numMembers(){return this.vecMembers.length}gensNoImprovement(){return this._gensNoImprovement}}function w(t,e,s,i){const r=e-t;return i.push({val:t+r/2,depth:s+1}),s>6||(w(t,t+r/2,s+1,i),w(t+r/2,e,s+1,i)),i}return{NeatGA:class{constructor(t,e,s){let r=new y(0,e,s);this.vecSplits=w(0,1,0,[]),this.vecBestGenomes=[],this.vecSpecies=[],this.SPECIES_COUNTER=0,this.GENOME_COUNTER=0,this.generation=0,this.popSize=t,this.totFitAdj=0,this.avFitAdj=0,this.fittestGenome=0,this._bestEverFitness=0,this.vecGenomes=i.fill(t,(()=>new y(this.nextGID(),e,s))),this.innovHistory=new f(r.neurons(),r.genes())}resetAndKill(){this.totFitAdj=0,this.avFitAdj=0;let t=[];this.vecSpecies.forEach((e=>{e.gensNoImprovement()>l.numGensAllowedNoImprovement&&e.bestFitness()<this._bestEverFitness||t.push(e.purge())})),this.vecSpecies.length=0,t.forEach((t=>this.vecSpecies.push(t)))}speciateAndCalculateSpawnLevels(){let t=!1;this.vecGenomes.forEach((e=>{for(let s=0;s<this.vecSpecies.length;++s)if(e.calcCompatibility(this.vecSpecies[s].leader())<=l.compatibilityThreshold){this.vecSpecies[s].addMember(e),t=!0;break}t||this.vecSpecies.push(new _(this.nextSID(),e)),t=!1})),this.vecSpecies.forEach((t=>t.adjustFitnesses())),this.vecGenomes.forEach((t=>this.totFitAdj+=t.adjustedFitness)),this.avFitAdj=this.totFitAdj/this.vecGenomes.length,this.vecGenomes.forEach((t=>t.amountToSpawn=t.adjustedFitness/this.avFitAdj)),this.vecSpecies.forEach((t=>t.calculateSpawnAmount()))}crossOver(t,e){let s;function r(t,e){e.indexOf(t)<0&&e.push(t)}s=t.fitness.score()==e.fitness.score()?t.numGenes()==e.numGenes()?i.randSign()>0?1:0:t.numGenes()<e.numGenes()?0:1:t.fitness.score()>e.fitness.score()?0:1;let o,h=[],l=[],a=[],u=0,d=0;for(;u!=t.endOfGenes()||d!=e.endOfGenes();)u==t.endOfGenes()&&d!=e.endOfGenes()?(1==s&&(o=e.vecLinks[d]),++d):d==e.endOfGenes()&&u!=t.endOfGenes()||t.vecLinks[u].innovationID<e.vecLinks[d].innovationID?(0==s&&(o=t.vecLinks[u]),++u):e.vecLinks[d].innovationID<t.vecLinks[u].innovationID?(1==s&&(o=e.vecLinks[d]),++d):e.vecLinks[d].innovationID==t.vecLinks[u].innovationID&&(o=i.rand()<.5?t.vecLinks[u]:e.vecLinks[d],++u,++d),0!=l.length&&i.last(l).innovationID==o.innovationID||l.push(o.clone()),r(o.fromNeuron,a),r(o.toNeuron,a);return a.sort().forEach((t=>h.push(function(t,e){let s=c.from(0,n.HIDDEN);for(let i,r=0;r<t.vecInnovs.length;++r)if(i=t.vecInnovs[r],i.neuronID==e)return s.neuronType=i.neuronType,s.id=i.neuronID,s.pos=i.pos.slice(),s;i.assert(!1,"boom from createNeuronFromID")}(this.innovHistory,t)))),new y(this.nextGID(),t.numInputs,t.numOutputs,h,l)}nextSID(){return++this.SPECIES_COUNTER}nextGID(){return++this.GENOME_COUNTER}tournamentSelection(t){let e=0,s=0;for(let r,n=0,o=this.vecGenomes.length-1;n<t;++n)r=i.randInt2(0,o),this.vecGenomes[r].fitness.score()>s&&(e=r,s=this.vecGenomes[r].fitness.score());return this.vecGenomes[e]}calculateNetDepth(t){let e=0;for(let s=0;s<t.numNeurons();++s)for(let i=0;i<this.vecSplits.length;++i)t.splitY(s)==this.vecSplits[i].val&&this.vecSplits[i].depth>e&&(e=this.vecSplits[i].depth);return e+2}sortAndRecord(t){this.vecGenomes.forEach(((e,s)=>e.setFitness(t[s]))),this.vecGenomes.sort(((t,e)=>t.fitness.score()>e.fitness.score()?-1:t.fitness.score()<e.fitness.score()?1:0)),this._bestEverFitness=Math.max(this._bestEverFitness,this.vecGenomes[0].fitness.score()),this.vecBestGenomes.length=0;for(let t=0;t<l.numBestElites;++t)this.vecBestGenomes.push(this.vecGenomes[t])}epoch(t){i.assert(t.length==this.vecGenomes.length,"NeatGA::Epoch(scores/ genomes mismatch)!"),this.resetAndKill(),this.sortAndRecord(t),this.speciateAndCalculateSpawnLevels();let e,r=[],n=0;if(this.vecSpecies.forEach((t=>{if(n<this.popSize){let s=!1,o=i.rounded(t.numToSpawn());for(;o--;){if(s){if(1==t.numMembers())e=t.spawn();else{let s,r=5,n=t.spawn();if(i.rand()<l.crossOverRate){for(s=t.spawn();n.id()==s.id()&&r--;)s=t.spawn();e=n.id()!=s.id()?this.crossOver(n,s):n}else e=n}e.setID(this.nextGID()),e.numNeurons()<l.maxPermittedNeurons&&e.addNeuron(l.chanceAddNode,this.innovHistory,l.numTrysToFindOldLink),e.addLink(l.chanceAddLink,l.chanceAddRecurrentLink,this.innovHistory,l.numTrysToFindLoopedLink,l.numAddLinkAttempts),e.mutateWeights(l.mutationRate,l.probabilityWeightReplaced,l.maxWeightPerturbation),e.mutateActivation(l.activationMutationRate,l.maxActivationPerturbation)}else s=!0,e=t.leader().clone();r.push(e.sortGenes()),++n==this.popSize&&(o=0)}}})),n<this.popSize){let t=this.popSize-n;for(;t--;)r.push(this.tournamentSelection(s(this.popSize/5)).clone())}return this.vecGenomes=r,++this.generation,this.createPhenotypes()}createPhenotypes(){return this.vecGenomes.map((t=>t.createPhenotype(this.calculateNetDepth(t))))}renderSpeciesInfo(){}numSpecies(){return this.vecSpecies.length}bestEverFitness(){return this._bestEverFitness}getBestPhenotypesFromLastGeneration(){return this.vecBestGenomes.map(((t,e)=>{t.createPhenotype(this.calculateNetDepth(t))}))}},NeuralNet:m,Genome:y,NeuronGene:c,LinkGene:u,NLink:g,NNeuron:p,Species:_,NumFitness:a,InnovHistory:f,NeuronType:n,InnovType:o,RunType:h,configParams:t=>i.inject(l,t)}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core")):t["io/czlab/mcfud/algo/NEAT"]=s}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());const s=Math.floor,{u:i,is:r}=e,n=0,o=1,h=2,l=3;function a(t,e=!1){return{value:t,gt(t){return e?this.value<t.value:this.value>t.value},eq(t){return this.value==t.value},lt(t){return e?this.value>t.value:this.value<t.value},score(){return this.value},update(t){this.value=t},clone(){return a(this.value,e)}}}const c=a,u={BIAS:1,nextInnovNo:1,superSpeed:1,mutationRate:.8,crossOverRate:.25,probAddLink:.07,probAddNode:.03,probCancelLink:.75,probAddRecurrentLink:.05,probWeightReplaced:.1,maxWeightPerturbation:.02,noImprovementLimit:15,excessCoeff:1,weightDiffCoeff:.5,compatibilityThreshold:3};class d{constructor(t,e,s,i){this.innovNo=i,this.fromNode=t,this.toNode=e,this.weight=s,this.enabled=!0}mutateWeight(){i.rand()<u.probWeightReplaced?this.weight=i.randMinus1To1():this.weight+=i.randGaussian()*u.maxWeightPerturbation,this.weight>1&&(this.weight=1),this.weight<-1&&(this.weight=-1)}clone(t,e){let s=new d(t,e,this.weight,this.innovNo);return s.enabled=this.enabled,s}}class f{constructor(t,e,s,i){this.fromNode=t,this.toNode=e,this.innovNumber=s,this.innovNumbers=i.slice()}matches(t,e,s){if(t.genes.length==this.innovNumbers.length&&e.number==this.fromNode&&s.number==this.toNode){for(let e=0;e<t.genes.length;++e)if(!this.innovNumbers.includes(t.genes[e].innovNo))return!1;return!0}return!1}}class g{constructor(t,e,s=0){this.outputConnections=[],this.layer=s,this.neuronType=t,this.pos=[0,0],this.number=e,this.inputSum=0,this.outputValue=0}engage(){0!=this.layer&&(this.outputValue=this.sigmoid(this.inputSum));for(let t=0;t<this.outputConnections.length;++t)this.outputConnections[t].enabled&&(this.outputConnections[t].toNode.inputSum+=this.outputConnections[t].weight*this.outputValue);return this}stepFunction(t){return t<0?0:1}sigmoid(t){return 1/(1+Math.pow(Math.E,-4.9*t))}sigmoid2(t,e){return 1/(1+Math.exp(-t/e))}isConnectedTo(t){let e,s;if(t.layer<this.layer?(e=t,s=this):t.layer>this.layer&&(e=this,s=t),e&&s)for(let t=0;t<e.outputConnections.length;++t)if(e.outputConnections[t].toNode===s)return!0;return!1}clone(){return new g(this.neuronType,this.number,this.layer)}}class p{constructor(t,e,s=!1){this.outputs=e,this.fitness=c(0),this.inputs=t,this.layers=2,this.nextNode=0,this.network=[],this.genes=[],this.nodes=s?[]:this.ctor(t,e,[])}ctor(t,e,s){for(let e=0;e<t;++e)s.push(new g(n,e)),++this.nextNode;for(let i=0;i<e;++i)s.push(new g(o,i+t,1)),++this.nextNode;return this.biasNode=this.nextNode,this.nextNode++,s.push(new g(h,this.biasNode)),s}bindTo(t){return this.husk=t,t.brain=this}getNeuron(t){return this.nodes.find((e=>e.number==t))}connectNeurons(){return this.nodes.forEach((t=>t.outputConnections.length=0)),this.genes.forEach((t=>t.fromNode.outputConnections.push(t))),this}update(t){i.assert(this.network.length>0,"invalid network"),i.assert(t.length==this.inputs,"invalid input values");for(let e,s=0;s<this.inputs;++s)e=this.nodes[s],e.outputValue=t[s],i.assert(e.neuronType==n,"invalid input neuron");this.nodes[this.biasNode].outputValue=u.BIAS,this.network.forEach((t=>t.engage()));const e=[];for(let t,s=0;s<this.outputs;++s)t=this.nodes[this.inputs+s],e[s]=t.outputValue,i.assert(t.neuronType==o,"invalid output neuron");return this.nodes.forEach((t=>t.inputSum=0)),e}compute(t){return this.update(t)}generateNetwork(){this.connectNeurons(),i.cls(this.network);for(let t=0;t<this.layers;++t)for(let e=0;e<this.nodes.length;++e)this.nodes[e].layer==t&&this.network.push(this.nodes[e]);return this}addNeuron(t){if(0==this.genes.length)return this.addLink(t);let e=10,s=0;for(this.genes.length>1&&(s=i.randInt(this.genes.length));this.genes[s].fromNode.neuronType==h&&e>0;)s=i.randInt(this.genes.length),e--;if(e<=0)return console.warn("failed to add neuron"),this;this.genes[s].enabled=!1;let r,n,o=this.nextNode;if(this.nodes.push(new g(l,o)),++this.nextNode,n=this.getNeuron(o),r=this.getInnovNo(t,this.genes[s].fromNode,n),this.genes.push(new d(this.genes[s].fromNode,n,1,r)),r=this.getInnovNo(t,n,this.genes[s].toNode),this.genes.push(new d(n,this.genes[s].toNode,this.genes[s].weight,r)),n.layer=1+this.genes[s].fromNode.layer,r=this.getInnovNo(t,this.nodes[this.biasNode],o),this.genes.push(new d(this.nodes[this.biasNode],n,0,r)),n.layer==this.genes[s].toNode.layer){for(let t=0;t<this.nodes.length-1;++t)this.nodes[t].layer>=n.layer&&(this.nodes[t].layer+=1);++this.layers}return this.connectNeurons()}addLink(t){if(this.fullyConnected())return console.warn("addLink failed, too full"),this;let e,s,r=i.randInt(this.nodes.length),n=i.randInt(this.nodes.length),o=10,h=(t,e)=>this.nodes[t].layer==this.nodes[e].layer||this.nodes[t].isConnectedTo(this.nodes[e]);for(;h(r,n)&&o>0;)r=i.randInt(this.nodes.length),n=i.randInt(this.nodes.length),--o;return o<=0?(console.log("failed to add-link"),this):(this.nodes[r].layer>this.nodes[n].layer&&(s=n,n=r,r=s),e=this.getInnovNo(t,this.nodes[r],this.nodes[n]),this.genes.push(new d(this.nodes[r],this.nodes[n],i.randMinus1To1(),e)),this.connectNeurons())}getInnovNo(t,e,s){let i=!0,r=u.nextInnovNo;for(let n=0;n<t.length;++n)if(t[n].matches(this,e,s)){i=!1,r=t[n].innovNumber;break}return i&&(t.push(new f(e.number,s.number,r,this.genes.map((t=>t.innovNo)))),u.nextInnovNo+=1),r}fullyConnected(){let t=0,e=i.fill(this.layers,0);this.nodes.forEach((t=>e[t.layer]+=1));for(let s,i=0;i<this.layers-1;++i){s=0;for(let t=i+1;t<this.layers;++t)s+=e[t];t+=s*e[i]}return t<=this.genes.length}mutate(t){return 0==this.genes.length&&this.addLink(t),i.rand()<u.mutationRate&&this.genes.forEach((t=>t.mutateWeight())),i.rand()<u.probAddLink&&this.addLink(t),i.rand()<u.probAddNode&&this.addNeuron(t),this}crossOver(t){let e,s,r=[],n=[],o=new p(this.inputs,this.outputs,!0);o.nextNode=this.nextNode,o.layers=this.layers,o.biasNode=this.biasNode;for(let o=0;o<this.genes.length;++o)s=!0,e=this.matchingGene(t,this.genes[o].innovNo),-1!=e?(this.genes[o].enabled&&t.genes[e].enabled||i.rand()<u.probCancelLink&&(s=!1),n.push(i.rand()<.5?this.genes[o]:t.genes[e])):(n.push(this.genes[o]),s=this.genes[o].enabled),r.push(s);this.nodes.forEach((t=>o.nodes.push(t.clone())));for(let t=0;t<n.length;++t)o.genes.push(n[t].clone(o.getNeuron(n[t].fromNode.number),o.getNeuron(n[t].toNode.number))),o.genes[t].enabled=r[t];return o.connectNeurons()}matchingGene(t,e){for(let s=0;s<t.genes.length;++s)if(t.genes[s].innovNo==e)return s;return-1}printGenome(){console.log("Prvar genome  layers:"+this.layers),console.log("bias node: "+this.biasNode),console.log("this.nodes");for(let t=0;t<this.nodes.length;++t)console.log(this.nodes[t].number+",");console.log("Genes");for(let t=0;t<this.genes.length;++t)console.log("gene "+this.genes[t].innovNo+"From node "+this.genes[t].fromNode.number+"To node "+this.genes[t].toNode.number+"is enabled "+this.genes[t].enabled+"from layer "+this.genes[t].fromNode.layer+"to layer "+this.genes[t].toNode.layer+"weight: "+this.genes[t].weight);return this}clone(){let t=new p(this.inputs,this.outputs,!0);return this.nodes.forEach((e=>t.nodes.push(e.clone()))),this.genes.forEach((e=>{t.genes.push(e.clone(t.getNeuron(e.fromNode.number),t.getNeuron(e.toNode.number)))})),t.fitness=this.fitness.clone(),t.layers=this.layers,t.nextNode=this.nextNode,t.biasNode=this.biasNode,t.connectNeurons()}drawGenome(t,e,s,i){return this}}class m{constructor(t){this.bestFitness=0,this.members=[],this.rep,this.staleness=0,this.averageFitness=0,t&&(this.bestFitness=t.fitness.score(),this.members.push(t),this.rep=t.clone())}compatible(t){let e,s=this.getExcessDisjoint(t,this.rep),i=this.averageWeightDiff(t,this.rep),r=t.genes.length-20;return r<1&&(r=1),e=u.excessCoeff*s/r+u.weightDiffCoeff*i,u.compatibilityThreshold>e}add(t){return this.members.push(t),this}getExcessDisjoint(t,e){let s=0;for(let i=0;i<t.genes.length;++i)for(let r=0;r<e.genes.length;++r)if(t.genes[i].innovNo==e.genes[r].innovNo){++s;break}return t.genes.length+e.genes.length-2*s}averageWeightDiff(t,e){if(0==t.genes.length||0==e.genes.length)return 0;let s=0,i=0;for(let r=0;r<t.genes.length;++r)for(let n=0;n<e.genes.length;++n)if(t.genes[r].innovNo==e.genes[n].innovNo){++s,i+=Math.abs(t.genes[r].weight-e.genes[n].weight);break}return 0==s?100:i/s}sortAsc(){this.members.sort(((t,e)=>t.fitness.score()>e.fitness.score()?-1:t.fitness.score()<e.fitness.score()?1:0)),0==this.members.length?this.staleness=200:this.members[0].fitness.score()>this.bestFitness?(this.bestFitness=this.members[0].fitness.score(),this.rep=this.members[0].clone(),this.staleness=0):++this.staleness}setAverage(){this.averageFitness=this.members.reduce(((t,e)=>t+e.fitness.score()),0)/this.members.length}giveMeBaby(t){let e,s=()=>{let t=this.members.reduce(((t,e)=>t+e.fitness.score()),0),e=0,s=i.rand()*t;for(let t=0;t<this.members.length;++t)if(e+=this.members[t].fitness.score(),e>s)return this.members[t];return this.members[0]};if(i.rand()<u.crossOverRate)e=s().clone();else{let t=s(),i=s();e=t.fitness.score()<i.fitness.score()?i.crossOver(t):t.crossOver(i)}return e.mutate(t)}cull(){this.members.length>2&&(this.members.length=s(this.members.length/2))}fitnessSharing(){this.members.forEach((t=>{t.fitness.update(t.fitness.score()/this.members.length)}))}}return{NeatGA:class{constructor(t,e,s){this.history=[],this.species=[],this.gen=1,this.genomes=i.fill(t,((t,i)=>((i=new p(e,s)).mutate(this.history),i.generateNetwork())))}createPhenotypes(){return this.genomes}epoch(t){let e=1==this.gen?null:this.genomes[0];this.speciate(),this.genomes.forEach(((e,s)=>{s>=0&&e.fitness.update(t[s])})),this.sortSpecies(),this.resetAndKill();let r,n=[],o=this.getAvgFitnessSum();for(this.species.forEach((t=>{n.push(t.rep.clone()),r=s(t.averageFitness/o*this.genomes.length)-1;for(let e=0;e<r;++e)n.push(t.giveMeBaby(this.history))})),e||(e=this.species[0].rep),n.length<this.genomes.length&&n.push(e.clone());n.length<this.genomes.length;)n.push(this.species[0].giveMeBaby(this.history));return i.append(this.genomes,n,!0),this.gen+=1,this.genomes.forEach((t=>t.generateNetwork())),this.genomes}speciate(){this.species.forEach((t=>i.cls(t.members)));for(let t,e,s=0;s<this.genomes.length;++s){e=this.genomes[s],t=!1;for(let s=0;s<this.species.length;++s)if(this.species[s].compatible(e)){this.species[s].add(e),t=!0;break}t||this.species.push(new m(e))}}sortSpecies(){this.species.forEach((t=>t.sortAsc())),this.species.sort(((t,e)=>t.bestFitness>e.bestFitness?-1:t.bestFitness<e.bestFitness?1:0))}getAvgFitnessSum(){return this.species.reduce(((t,e)=>t+e.averageFitness),0)}resetAndKill(){let t=[];this.species.forEach((t=>{t.cull(),t.fitnessSharing(),t.setAverage()}));for(let e=0;e<this.species.length;++e)(e<2||this.species[e].staleness<u.noImprovementLimit)&&t.push(this.species[e]);i.append(this.species,t,!0);let e=this.getAvgFitnessSum();t=[];for(let s=0;s<this.species.length;++s)s<1?t.push(this.species[s]):this.species[s].averageFitness/e*this.species.length<1||t.push(this.species[s]);i.append(this.species,t,!0)}massExtinction(){this.species.length>5&&this.species.slice(0,5)}},Genome:p,LinkGene:d,Neuron:g,Species:m,NumFitness:a,InnovHistory:f,configParams:t=>i.inject(u,t)}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core")):t["io/czlab/mcfud/algo/NEAT2"]=s}(this),function(t,e){"use strict";function s(e,s){e||(e=t["io/czlab/mcfud/core"]()),s||(s=t["io/czlab/mcfud/math"]());const{is:i,u:r}=e;function n(t,e,s){return e>t.length-1?t:`${t.substr(0,e)}${s}${t.substr(e+1)}`}function o(t,e){return+t.charAt(e)}class h{static DV={n:1,s:2,e:4,w:8};static DX={e:1,w:-1,n:0,s:0};static DY={e:0,w:0,n:-1,s:1};static OPPOSITE={e:"w",w:"e",n:"s",s:"n"};constructor(t,e){this.COLS=t,this.ROWS=e,this._getEntryNodes()}_getEntryNodes(){let t={},e=2*this.ROWS+1-2,s=2*this.COLS+1-2;t.start={x:1,y:1,gate:{x:0,y:1}},t.end={x:s,y:e,gate:{x:s+1,y:e}},this.entryNodes=t}getIO(){let t=this.entryNodes.end.gate,e=this.entryNodes.start.gate;return{start:[e.x,e.y],end:[t.x,t.y]}}generate(){this.grid=this._walk(0,0,r.fill(this.ROWS,(()=>r.fill(this.COLS,0))))}canSouth(t){return 0!=(t&h.DV.s)}canEast(t){return 0!=(t&h.DV.e)}toAscii(){let t=this.grid,e=t.length,s=[],i=t[0].length;for(let r,n=0;n<e;++n){r="|";for(let e=0;e<i;++e)r+=this.canSouth(t[n][e])?" ":"_",this.canEast(t[n][e])?r+=this.canSouth(t[n][e]|t[n][e+1])?" ":"_":r+="|";s.push(r)}return s.unshift("_".repeat(s[0].length)),s.join("\n")}_walk(t,e,s){let i,n;return r.shuffle(["n","s","e","w"]).forEach((r=>{i=t+h.DX[r],n=e+h.DY[r],n>=0&&n<s.length&&i>=0&&i<s[n].length&&0==s[n][i]&&(s[e][t]|=h.DV[r],s[n][i]|=h.DV[h.OPPOSITE[r]],this._walk(i,n,s))})),s}toGrid(){let t,e,s=this.grid,i=s.length,n=[],o=s[0].length;for(let r,h=0;h<i;++h){t=[],e=[],r=0,t[r]=1,e[r]=1;for(let i=0;i<o;++i)++r,this.canSouth(s[h][i])?(t[r]=0,e[r]=0):(t[r]=0,e[r]=1),++r,this.canEast(s[h][i])?(t[r]=0,e[r]=1):(t[r]=1,e[r]=1);n.push(t,e)}return n.unshift(r.fill(n[0].length,1)),n}}return{Maze1:class{constructor(t,e,s="D",i={}){let{bias:r,removeWalls:n,maxWallsRemove:o}=i;this.bias=r||"",this.removeWalls=n||0,this.maxWallsRemove=o||300,this.ROWS=t,this.COLS=e,this.matrix=[],this.entryNodes=this.getEntryNodes(s)}generate(){this.getMatrix(this.parseMaze(r.fill(this.COLS*this.ROWS,(()=>"01111")))),this.removeMazeWalls()}toAscii(){return""}getIO(){let t=this.entryNodes.end.gate,e=this.entryNodes.start.gate;return{start:[e.x,e.y],end:[t.x,t.y]}}toGrid(){let t,e=[];return this.matrix.forEach(((s,i)=>{t=[];for(let e=0;e<s.length;++e)t[e]="1"==s.charAt(e)?1:0;e.push(t)})),e}parseMaze(t){const e={n:1,s:2,w:3,e:4},i={n:2,s:1,w:4,e:3};let h,l,a,c=0,u=[],d=0,f=3,g=t.length-1,p=r.randInt(t.length);for(this.bias&&("H"==this.bias?f=this.COLS/100>=1?s.ndiv(this.COLS,100)+2:3:"V"==this.bias&&(f=this.ROWS/100>=1?s.ndiv(this.ROWS,100)+2:3)),t[p]=n(t[p],0,1);c<g;)if(++d,h=this.getNeighbours(p),a=Object.keys(h).filter((e=>-1!=h[e]&&!o(t[h[e]],0))),this.bias&&d!=f?a=this.biasDirections(a):d=0,a.length)++c,a.length>1&&u.push(p),l=a[r.randInt(a.length)],t[p]=n(t[p],e[l],0),p=h[l],t[p]=n(t[p],i[l],0),t[p]=n(t[p],0,1);else{if(0==u.length)break;p=u.pop()}return t}getMatrix(t){let e="",s="",i=this.COLS*this.ROWS;r.assert(t.length==i,"invalid nodes");for(let r=0;r<i;++r){if(e+=0==e.length?"1":"",s+=0==s.length?"1":"",o(t[r],1))e+="11",s+=o(t[r],4)?"01":"00";else{let i=t.hasOwnProperty(r-this.COLS)&&o(t[r-this.COLS],4),n=t.hasOwnProperty(r+1)&&o(t[r+1],1);o(t[r],4)?(e+="01",s+="01"):n||i?(e+="01",s+="00"):(e+="00",s+="00")}(r+1)%this.COLS==0&&(this.matrix.push(e,s),e="",s="")}this.matrix.push("1".repeat(2*this.COLS+1))}getEntryNodes(t){let e={},s=2*this.ROWS+1-2,i=2*this.COLS+1-2;if("D"==t&&(e.start={x:1,y:1,gate:{x:0,y:1}},e.end={x:i,y:s,gate:{x:i+1,y:s}}),"H"==t||"V"==t){let r="H"==t?s:i;r=(r-1)/2;let n=r%2==0;r=n?r+1:r;let o="H"==t?1:r,h="H"==t?r:1,l="H"==t?i:n?o:o+2,a="H"==t?n?h:h+2:s,c="H"==t?{x:0,y:h}:{x:o,y:0},u="H"==t?{x:i+1,y:a}:{x:l,y:s+1};e.start={x:o,y:h,gate:c},e.end={x:l,y:a,gate:u}}return e}biasDirections(t){let e=-1!=t.indexOf("w")||-1!=t.indexOf("e"),s=-1!=t.indexOf("n")||-1!=t.indexOf("s");return"H"==this.bias&&e?t.filter((t=>"w"==t||"e"==t)):"V"==this.bias&&s?t.filter((t=>"n"==t||"s"==t)):t}getNeighbours(t){return{w:t>0&&t%this.COLS!=0?t-1:-1,e:(t+1)%this.COLS!=0?t+1:-1,n:t-this.COLS>=0?t-this.COLS:-1,s:this.COLS*this.ROWS>t+this.COLS?t+this.COLS:-1}}removeWall(t,e){const s=t%2==0,i=e%2==0;if(!o(this.matrix[t],e))return!1;if(!s&&i){const s=t-2>0&&1==o(this.matrix[t-2],e),i=t+2<this.matrix.length&&1==o(this.matrix[t+2],e);if(s&&i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0;if(!s&&i){const s=1==o(this.matrix[t-1],e-1),i=1==o(this.matrix[t-1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}else if(!i&&s){const s=1==o(this.matrix[t+1],e-1),i=1==o(this.matrix[t+1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}}else if(s&&!i){const s=1==o(this.matrix[t],e-2),i=1==o(this.matrix[t],e+2);if(s&&i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0;if(!s&&i){const s=1==o(this.matrix[t-1],e-1),i=1==o(this.matrix[t+1],e-1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}else if(!i&&s){const s=1==o(this.matrix[t-1],e+1),i=1==o(this.matrix[t+1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}}}removeMazeWalls(){if(0==this.removeWalls||0==this.matrix.length)return;let t,e,s=0,i=this.matrix.length-1,n=this.maxWallsRemove;for(;s<n&&(++s,!(this.wallsRemoved>=this.removeWalls));){let s=r.randInt2(1,i);s=s==i?s-1:s,e=[],t=this.matrix[s];for(let s=0;s<t.length;s++)0!=s&&s!=t.length-1&&o(t,s)&&e.push(s);r.shuffle(e);for(let t=0;t<e.length;t++)if(this.removeWall(s,e[t])){++this.wallsRemoved;break}}}},Maze2:h}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core"),require("../main/math")):t["io/czlab/mcfud/algo/maze"]=s}(this);